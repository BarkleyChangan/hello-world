***************** 系统 *****************
# Linux命令在线查询网站
https://man.linuxde.net

# 调小TCP协议的time_wait超时时间(系统默认240秒)
/etc/sysctl.conf
net.ipv4.tcp_fin_timeout=30

# 桌面和命令行模式互相切换
ctrl + alt + F(1~6)

# 数据同步写入磁盘
sync

# 运行级别
init 0 关机
     1 单用户
     2 多用户状态没有网络服务
     3 多用户状态有网络服务
     4 系统未使用保留给用户
     5 图形界面
     6 系统重启

# 关机
shutdown -h now

# 重启
shutdown -r now

# 修改默认的运行级别
/etc/inittab的id:3:initdefault:这一行中的数字

# 将当前窗口切换成图形化界面
startx

# 动态观察进程变化(使用q退出)
top [-d 数字] | top [-bnp]
     -d 后面可以接秒数,就是整个进程画面更新的秒数,预设是5秒
     -b 以批次的方式执行top,还有更多的参数可以使用哦
        通常会搭配数据流重导向来将批次的结果输出成文件
     -n 与-b搭配,意义是需要进行几次top的输出结果
     -p 指定某些个PID来进行观察检测而已
     在top执行过程中可以使用的按键指令:
     ? 显示在top当中可以输入的按键指令
     P 以CPU的使用资源排序显示
     M 以Memory的使用资源排序显示
     N 以PID来排序哦
     T 由该Process使用的CPU时间累积TIME+排序
     k 给与某个PID一个讯号
     r 给与某个PID重新制定一个nice值
     q 离开

# 查看内存使用情况
free [-b|-k|-m|-g|-h] [-t] [-s N -c N]
      -b 直接输入free时,显示的单位是Kbytes,我们可以使用b(Bytes),m(MBytes),k(KBytes)以及g(GBytes)来显示单位,也可以直接让系统自己指定单位-h
      -t 在输出的最终结果中,显示物理内存与swap的总量
      -s 可以让系统每几秒钟输出一次,不间断的一直输出的意思.对于系统观察有效
      -c 与-s同时处理~让free列出几次的意思
free -m

# 查阅系统与核心相关信息
uname [-asrmpi]
       -a 所有系统相关信息,包括底下的数据都会被列出来
       -s 系统核心名称
       -r 核心的版本
       -m 本系统的硬件名称,例如i686或x86_64
       -p CPU的类型,与-m类似,只是显示的是CPU的类型
       -i 硬件平台ix86

# 查看系统的启动时间与工作负载
uptime 显示top命令最上面一行

# 查看启动的进程
ps aux 观察系统所有的进程数据
ps -lA 也是能观察所有系统的数据
ps axjf 连同部分进程树状态
   -A 所有的process均显示,与-e具有同样的效果
   -a 不与terminal有关的所有process
   -u 有效用户相关的process
   x  通常与a这个参数一起使用,可列出较完整的信息
   输出格式规划
   l 较长、较详细的将该PID的信息列出
   j 工作的格式
   -f 做一个更为完整的输出

ps -aux | grep nginx
        USER 进程创建者的用户名
        PID  进程的ID号
        %CPU 进程占用的CPU百分比
        %MEM 进程占用的内存百分比
        VSZ  进程占用的虚拟内存大小
        RSS  内存中的页数量(页是管理内存的单位,在PC上通常为4K)
        TTY  进程所在终端的ID号
        STAT R 正在运行/可运行
             D 睡眠中(不可被唤醒,通常是在等待I/O设备)
             S 睡眠中(可以被唤醒)
             T 停止(由于收到信号或被跟踪)
             Z 僵尸进程(已经结束而没有释放系统资源的进程)
             < 进程拥有比普通优先级高的优先级
             N 进程拥有比普通优先级低的优先级
             L 有些页面被锁在内存中
             s 会话的先导进程
        START 进程启动的时间
        TIME  进程已经占用的CPU时间
        COMMAND 命令和参数
ps -lax  可以提供父进程ID(PPID)和谦让度(NI)但不会显示进程属主的用户名
ps -l 仅查看自己的bash相关进程
ps aux 查看系统所有进程
ps -L 1213 特定进程的线程
ps -C getty 通过进程名查看进程
ps -axjf 树形的显示进程

# pstree
pstree [-A|U] [-up]
        -A 各进程树之间的连接以ASCII字符来连接
        -U 各进程树之间的连接以万国码的字符来连接,在某些终端接口下可能会有错误
        -u 并同时列出每个process的PID
        -p 并同时列出每个process的所属用户

# 使用进程的名称来杀死进程
killall [-iIe] [command name]
         -i 交互式的,若需要删除时会出现提示字符给用户
         -e 表示后面接的command name要一致,但整个完整的指令不能超过15个字符
         -I 指令名称(可能含参数)忽略大小写
killall -1 rsyslogd
killall -9 httpd
killall -i -9 bash

# 指定nice值启动进程
nice [-n 数字] command
      -n 后面接一个数值,范围-20-19

# 已存在进程的nice重新调整
renice [number] PID
        PID 某个进程的ID
         
# 查看占用文件的进程
lsof database.doc

# 终止进程
kill PID进程号
kill -9 PID进程号
kill -signal %jobnumber
     -l 列出目前kill能够使用的信号有哪些
     signal 代表给与后面接的那个工作什么样的指示
     -1 重新读取一次参数的配置文件
     -2 代表与由键盘输入ctrl -c同样的动作
     -9 立刻强制删除一个工作
     -15 以正常的进程方式终止一项工作,与-9是不一样的
常用的信号       信号名      描述                                 默认情况下执行的操作
0                     EXIT        程序退出时收到该信号        终止
1                     HUP        挂起                                 终止
2                     INT         中断                                 终止
3                     QUIT       退出                                 终止
9                     KILL        杀死                                  终止
11                   SEGV       段错误                              终止
15                   TERM      软件终止                           终止
取决于硬件体系   USR1    用户定义                           终止
取决于硬件体系   USR1    用户定义                           终止

# 启动程序时设置进程的谦让度(-20~+19之间浮动)
nice -n 2 hello
                -n 将-n后的数值加上默认的谦让度值(相对谦让度);不带-n参数会将程序的谦让度设置为10
nice 查看默认的谦让度

# 进程运行时调整谦让度(绝对谦让度)
renice +12 -p 8567

# 查看目前使用的是哪种shell
env  该命令显示当前操作系统的环境变量
 
# 以后台的方式启动eclipse
./eclipse &

# 显示使用过的命令(这些信息被存储在用户主目录的.bash_history文件中,默认可以存储1000条命令)
history
history 10

# 执行历史编号为5的命令
!5

# 执行最后一次以ls开头的命令
!ls

# 显示系统时间
date

# 更改系统时间(月月日日时时分分年年年年.秒秒)
date MMDDHHMMCCYY.SS

# 查看日历(查看2002年3月的日历)
cal 3 2002

# 查看年历
cal 2008

# 指示程序在后台运行
firefox &

# 查看当前系统中登录人
who
w

# 查看每个账号最近登入时间(读取/var/log/lastlog)
lastlog

# 查看当前登录人
whoami

# 共享文件夹
vmhgfs-fuse .host:/share /mnt/hgfs

# 向用户发消息
write 用户名 [用户所在终端接口]
write vbird1 pts/2

# 用户是否接受信息
mesg n 不接受
mesg y 接受
mesg   查看状态

# 广播消息
wall "I will shutdown my linux server..."

# 加密密码并存入/etc/shadow中
echo "vbird3:abcdefg" | chpassd

# 显示Linux中的任务列表及任务状态,包括后台运行的任务
jobs [-lrs]
      -l 除了列出job nubmer与指令串外同时列出PID
      -p 仅任务对应的显示进程号
      -n 显示任务状态的变化
      -r 仅列出正在后台运行的工作
      -s 仅列出正在后台暂停的工作
+代表预设的取用工作;代表最近被放到背景的工作号码
-代表最近最后第二个被放置到背景中的工作号码

# 将背景工作拿到前台来处理
fg %jobnumber
   %jobnumber 为工作号码(数字),注意:那个%是可有可无的

# 让后台任务执行
bg %jobnumber

# 脱机情况下可以继续执行任务
nohup [指令与参数]   在终端机前台中工作
nohup [指令与参数] & 在终端机后台中工作

# 获取自己bash的PID
echo $$

# 分析核心产生的信息
dmesg

# 侦测系统资源变化
vmstat [-a] [延迟[总计侦测次数]] CPU/内存等信息
vmstat [-fs] 内存相关
vmstat [-S 单位] 设定显示数据单位
vmstat [-d] 与磁盘有关
vmstat [-p 分区槽] 与磁盘有关
        -a 使用inactive/active(活跃与否)取代buffer/cache的内存输出信息
        -f 开机到目前为止,系统复制fork的进程数
        -s 将一些事件(开机至目前为止)导致的内存变化情况列表说明
        -S 后面可以接单位,让显示的数据有单位。例如K/M取代bytes的容量
        -d 列出磁盘的读写总量统计表
        -p 后面列出分区槽,可显示该分区槽的读写总量统计表
vmstat 1 3 统计目前主机CPU状态,每秒一次,共计三次

# 查看进程正在使用的文件
fuser [-umv] [-k [i] [-signal]] file/dir
       -u 除了进程的PID之外,同时列出该进程的拥有着
       -m 后面接的那个档名会主动的上提到该文件系统的最顶层,对umountu成功很有效
       -v 可以列出每个文件与进程还有指令的完整相关性
       -k 找出使用该文件/目录的PID,并试图以SIGKILL这个讯号给与该PID
       -i 必须与-k配合,在删除PID之前会先询问用户意愿
       -signal 例如-1 -15等,若不加的话预设是SIGKILL(-9)

# 列出被进程所开启的文件名
lsof [-aUu] [+d]
      -a 多项数据需要同时成立才显示出结果
      -U 仅列出Unix like系统的socket文件类型
      -u 后面接username,列出该使用者相关进程所开启的文件
      +d 后面接目录,也即找出某个目录下已经被开启的文件

# 找出某支正在执行程序的PID
pidof [-sx] programname
       -s 仅列出一个PID而不列出所有的PID
       -x 同时列出该program name可能的PPID那个进程的PID

# 查看SELinux服务主配置文件中定义的状态
cat /etc/selinux/config

# 获取SElinux目前的模式
getenforce

# 查看SELinux政策
sestatus [-vb]
           -v 检查位于/etc/sestatus.conf内的文件与进程的安全性本文内容
           -b 将目前政策的规则布尔值列出,也即某些规则rule是否要启动0/1之意

# 让SELinux模式在enforcing与permissive之间切换的方法
setenforce [0|1]
            0 转为permissive宽容模式
            1 转为enforcing强制模式

# SELinux各个规则的布尔值查询
getsebool [-a] [规则名称]
           -a 列出目前系统上所有SELinux规则的布尔值为开启或关闭

# SELinux各个规则规范主体进程能够读取文件SELinux type查询seinfo,sesearch
seinfo [-Atrub]
        -A 列出SELinux的状态、规则布尔值、身份识别、角色、类别等所有信息
        -u 列出SELinux的所有身份识别user种类
        -r 列出SELinux的所有角色role种类
        -t 列出SELinux的type种类
        -b 列出所有规则的种类

sesearch [-A] [-s 主题类别] [-t 目标类别] [-b 布尔值]
          -A 列出后面数据中允许读取或放行的相关数据
          -t 后面还要接类别,例如-t httpd_t
          -b 后面还要接SELinux的规则,例如-b httpd_enable_ftp_server

# 修改SELinux规则的布尔值setsebool
setsebool [-P] [规则名称] [0|1]
           -P 直接将设定值写入配置文件,该设定数据未来会生效的

# 手动修改文件的SELinux type
chcon [-R] [-t type] [-u user] [-r role] 文件
chcon [-R] --reference=范例文件 文件
       -R 连同该目录下的次目录也同时修改
       -t 后面接安全性本文的类型字段,例如httpd_sys_content_t
       -u 后面接身份识别,例如system_u(不重要)
       -r 后面接角色,例如system_r(不重要)
       -v 若有变化成功,请将变动的结果列出来
       --reference=范例文件:拿某个文件当范例来修改后的续接的文件的类型

# 让文件恢复正确的SELinux type(将设置好的SELinux安全上下文立即生效)
restorecon [-Rv] 文件或目录
            -R 连同次目录一起修改
            -v 将过程显示到屏幕上

# 默认的安全性本文查询与修改
semanage {login|user|port|interface|fcontext|translation} -l
semanage fcontext -{a|d|m} [-frst] file_spec
         fcontext 主要用在安全性本文方面的用途
         -l为查询的意思
         -a 增加,你可以增加一些目录的默认安全性本文类型设定
         -m 修改
         -d 删除

# 修改时区
timedatectl [command]
             list-timezones 列出系统上所有支持的时区名称
             set-timezone 设定时区位置
             set-time 设定时间
             set-ntp  设定网络校时系统
timedatectl set-time "2015-09-01 12:02"

# 将正确的时间写入BIOS
hwclock -w

# 解析硬件设备
dmidecode -t type 
             1 详细的系统数据,含主板的型号与硬件的基础数据
             4 CPU的相关资料,包括倍频、外频、核心数、核心绪数等
             9 系统的相关插槽格式,包括PCI、PCI-E
             17 每一个内存插槽的规格,若内有内存,则列出该内存的容量与型号

# 列出系统PCI接口装置
lspci [-vvn]
       -v 显示更多的PCI接口装置的详细信息
       -vv 比-v还要更详细的信息
       -n 直接观察PCI的ID是不是厂商的名称

# 查看系统USB装置
lsusb [-t]
       -t 使用类似树状的目录来显示各个USB端口的信息

# 刷新DNS缓存
sudo /etc/init.d/networking restart

# 将本机时间与时间服务器的时间进行同步
yum install ntpdate
ntpdate ntp7.aliyun.com
***************** 系统 *****************

***************** 开发 *****************
# 清空日志文件
cat /dev/null > catalina.out

# 后台进程
tar -zpcf /tmp/etc.tar.gz /etc &

# 使用16进制打开class文件
vim test.class
然后在交互模式下,输入:%!xxd即可

# 实时读取日志文件
tail -F linuxidc_log

# 读取压缩日志而不解压缩
使用zless，zcat，zgrep等命令查看压缩包的内容，甚至不必显式提取压缩文件
zcat linuxidc_log.zip | more

# 获取命令最后的参数
ls m.linuxidc.com
cd !$

mv /path/to/错误的文件 /some/other/place
mv /path/to/对的文件 !$

# 获取命令的第n个参数
!:n
!: 代表最后一个参数

tar -cvf afolder afolder.tar
!:0 !:1 !:3 !:2

# 获取所有参数
!:1-$

zip -cvf afolder.tar afolder
tar !:1-$

# 获取倒数第n条命令的参数
!-n:$

mv /path/to/wrongfile /some/other/place
ls !-2:$

# 获取最后一个参数对应的路径
!$:h

tar -cvf system.tar /etc/afile
cd !$:h

# 获取当前行第1个元素
!#:1

cp /path/to/some/file !#:1.bak

# 替换命令中的字符串
!!:gs

echo my f key doef not work
!!:gs/does/did/
***************** 开发 *****************

***************** Daemon Service *****************
# 制定执行等级默认要启动的服务
chkconfig daemon on 
chkconfig daemon off
chkconfig daemon --list daemon

# 管理服务
systemctl [command] [unit]
           command主要有:
           start 立刻启动后面接的unit
           stop  立刻关闭后面接的unit
           restart 立刻关闭后启动后面接的unit,也即执行stop再执行start
           reload 不关闭后面接的unit情况下,重载配置文件,让设定生效
           enable 设定下次开机时,后面接的unit会被启动
           disable 设定下次开机时,后面接的unit不会被启动
           status 目前后面接的这个unit的状态,会列出有没有正在执行、开机预设执行否、登录等信息
           mask 注销
           unmask 取消注销
           is-active 目前有没有正在运行中
           is-enabled 开机时服务是否被设为开机自动启用
查看系统上所有的服务
systemctl [command] [--type=TYPE] [--all]
           list-units 依据unit列出目前有启动的unit,若加上--all才会列出没启动的
           list-units-files 依据/usr/lib/systemd/system/内的文件,将所有文件列表说明(查看启动项)
           --type=TYPE unit type,主要有service,socket,target等

查看系统中所有的单元
systemctl list-unit-files
查看正在运行的单元
systemctl list-units
查看系统当前所有的服务
systemctl list-unit-files --type=service

查看目前的模式
systemctl [command] [unit.target]
           get-default 取得目前的target
           set-default 设定后面接的target成为默认的操作模式
           isolate 切换到后面接的模式
 
systemctl poweroff 系统关机
systemctl reboot 重新启动
systemctl suspend 进入暂停模式
systemctl hibernate 进入休眠模式
systemctl rescue 强制进入救援模式
systemctl emergency 强制进入紧急救援模式

分析服务之间的依赖
systemctl list-dependencies [unit] [--reverse]
          --reverse 反向追踪谁使用这个unit

systemctl list-sockets

# 查看系统启动时间
systemd-analyze

# 查看每个服务的启动耗时
systemd-analyze blame

# 查看登录信息
journalctl [-nrpf] [--since TIME] [--until TIME] _optional
            预设会秀出全部的log内容,从旧的输出到最新的信息
            -n 显示最近的几行的意思~找出最新的信息相当有用
            -r 反向输出,从最新的输出到最旧的数据
            -p 显示后面所接的信息重要性排序
            -f 类似tali -f的功能,持续显示journal日志的内容(实时监测时相当有帮助)
            --since --until 设定开始与结束的时间,让在该期间的数据输出而已
            _SYSTEMD_UNIT=unit.service 只输出unit.service的信息而已
            _COMM=bash 只输出与bash有关的信息
            _PID=pid   只输出PID号码的信息
            _UID=uid   只输出UID为uid的信息
            SYSLOG_FACILITY=[0-23] 使用syslog.g规范的服务相对序号来呼叫出正确的数据

# logger指令
logger [-p 服务名称.等级] "信息"

# 核心模块的各项相依性
depmod [-Ane]
        -A 不加任何参数,depmod会主动的去分析目前核心的模块,并且重新写入/lib/modules/$(uname -r)/modules.dep当中。若加入-A参数时,则depmod会去搜寻比modules.dep内还要新的模块,如果真的找到新模块,才会更新
        -n 不写入modules.dep,而是将结果输出到屏幕上
        -c 显示出目前已加载的不可执行的模块名称

# 查看核心模块
lsmod

# 查看模块信息
modinfo [-adln] [module_name|filename]
         -a 仅列出作者名称
         -d 仅列出该modules的说明
         -l 仅列出授权
         -n 仅列出该模块的详细路径

# 加载模块
modprobe [-cfr] module_name
          -c 列出目前系统所有的模块(更详细的代号对应表)
          -f 强制加载该模块
          -r 类似rmmod,移除某个模块
insmod 不会主动分析模块的相依性

insmod [/full/path/module_name] [parameters]

# 移除模块
rmmod [-fw] module_name
       -f 强制将该模块移除,不论是否正被使用
***************** Daemon Service *****************

***************** 用户权限 *****************
# /etc/passwd记录用户信息,此文件对所有用户可读
# /etc/shadow保存用户登录密码,此文件只能用root账号查看
# /etc/group记录用户组

# 检查用户信息
finger [-s]username
        -s 仅列出用户的账号、全名、终端机代号与登入时间等等
        -m 列出与后面接的账号相同者,而不是利用部分比对(包括全名称)

# 修改finger信息
chfn [-foph] [username]
      -f 后面接完整的大名
      -o 办公室的房间号码
      -p 办公室的电话号码
      -h 家里的电话号码

# change shell
chsh [-ls]
      -l 列出目前系统上面可用的Shell,其实就是/etc/shells的内容
      -s 设定修改自己的Shell

# 查看shadow使用哪种加密机制
authconfig --test | grep hashing

# 添加用户
useradd [-u UID][-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名称
         -u 后面接UID,是一组数字。直接指定一个特定的UID给这个账号
         -g 后面接的那个组名就是初始群组,该群组的GID会被放置到/etc/passwd第四个字段内
         -G 后面接的那个组名就是这个账号还可以加入的群组,这个选项与参数会修改/etc/group内的相关数据
         -M 强制!不要建立用户家目录!(系统账号默认值)
         -m 强制!要建立用户家目录!(一般账号默认值)
         -c 这个就是/etc/passwd的第五栏说明内容,可以随便设定
         -d 指定某个目录为家目录,而不要使用默认值,务必使用绝对路径
         -r 建立一个系统账号,这个账号的UID会有限制(参考/etc/login.defs)
         -s 后面接一个shell,若没有指定则预设是/bin/bash
         -e 后面接一个日期,格式为YYYY-MM-DD,此项目可写入shadow第八个字段,也即账号失效日的设定项目
         -f 后面接shadow第七个字段,指定该密码是否会失效.0为立刻失效,-1为永远不失效(密码只会过期而强制于登入时重新设定)
         -D 查看useradd的默认值

# 修改密码
passwd [--stdin] 账号名称 # 所有人均可使用来修改自己的密码
passwd [-l] [-u] [--stdin][-S] [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号 # root功能
        --stdin 可以透过来自前一个管线的数据,作为密码输入,对Shell Script有帮助!
        -l 是LOCK的意思,会将/etc/shadow第二栏最前面加上!是密码失效
        -u 与-l相对,是UNLOCK的意思
        -S 列出密码相关参数,也即shadow文件内的大部分信息
        -n 后面接天数,shadow的第4个字段,多久不可修改密码天数
        -x 后面接天数,shadow的第5个字段,多久内必须要修改密码
        -w 后面接天数,shadow的第6个字段,密码过期前的警告天数
        -i 后面接日期,shadow的第7个字段,密码失效日期
echo "newpassword" | passwd -stdin barkley

# 显示密码详细参数
chage [-ldEImMW] 账号名
       -l 列出该账号的详细密码参数
       -d 后面接日期,修改shadow第3个字段(最近一次修改密码的日期),格式YY-MM-DD
       -E 后面接日期,修改shadow第8个字段(账号失效日),格式YY-MM-DD
       -I 后面接天数,修改shadow第7个字段(密码失效日期)
       -m 后面接天数,修改shadow第4个字段(密码最短保留天数)
       -M 后面接天数,修改shadow第5个字段(密码多久需要进行变更)
       -W 后面接天数,修改shadow第6个字段(密码过期前的警告日期)

# 建立一个名为agetest账号,该账号第一次登入使用默认密码,但登入后就提示修改密码
useradd agetest
echo "agetest" | passwd --stdin agetest
chage -d 0 agetest
chage -l agetest | head -n 3

# 删除用户
userdel [-r] username
         -r 连同用户的家目录也一起删除

# 管理账号
usermod [-cdegGlsuLU] username
         -c 后面接账号说明,即/etc/passwd第五栏的说明栏,可以加入一些账号的说明
         -d 后面接账号的家目录,即修改/etc/passwd的第六栏
         -e 后面接日期,格式是YYYY-MM-DD也就是在/etc/shadow内的第八个字段数据
         -f 后面接天数,为shadow的第七字段
         -g 后面接初始群组,修改/etc/passwd的第四个字段,即GID
         -G 后面接次要群组,修改这个用户能够支持的群组,修改的是/etc/group
         -a 与-G合用,可增加次要群组的支持而非设定
         -l 后面接账号名称,也即修改账号名称,/etc/passwd的第一栏
         -s 后面接Shell的实际文件,例如/bin/bash
         -u 后面接UID数字,即/etc/passwd第三栏
         -L 暂时将用户的密码冻结,让他无法登入。其实仅修/etc/shadow的密码栏
         -U 将/etc/shadow密码栏的!去掉,解冻账号

# 查看用户id
id [username]

# 用户切换(尽量通过绝对路径使用su命令)
su [-lm] [-c 指令] [username]
    - 单纯使用-代表使用login-shell的变量文件读取方式来登入系统,若用户名没有加上去,则代表切换为root身份
    -l 与-类似,但后面需要加欲切换的用户名,也是login-shell方式
    -m -m与-p是一样的,表示使用目前的环境设定,而不是读取新用户的配置文件
    -c 仅执行一次命令,所以-c后面可以加上指令
单纯使用su切换root时,读取的变量设定方式为non-login shell的方式,这种方式很多原本的变量不会改变,尤其是PATH变量

# 回到之前的账号
exit

# 以root身份执行命令(配置/etc/sudoers指定用户可以执行特权命令,修改此文件要使用visudo命令)
sudo [-b] [-u 用户名]
      -b 将后续的指令放到背景中让系统自行执行,而不与目前的Shell产生影响
      -u 后面可以接欲切换的用户名,若无此项则代表切换身份为root

# 修改/etc/sudoer(在结束离开修改画面时,系统会去检查/etc/sudoers的语法)
visudo
visudo 添加NOPASSWD参数执行时不需要输入密码

用户名 来源主机=(可切换的身份) 可下达的指令(使用绝对路径)
root       ALL=(ALL)                 ALL

# 查看当前账号支持的群组
groups

# 有效群组切换(以另外一个Shell来提供这个功能)
newgrp 群组名称
exit   # 注意!记得离开newgrp的环境

# 添加组
groupadd [-g gid] [-r] 组名
          -g 后面接某个特定的GID,用来直接给与某个GID
          -r 建立系统群组,与/etc/login.defs内的GID_MIN有关

# 修改群组
groupmod [-g gid] [-n group_name] 群组名
          -g 修改已有的GID数字
          -n 修改已有的组名

# 删除群组
groupdel [groupname]

# 群组管理员
gpasswd groupname 若没有任何参数,表示给与groupname一个密码/etc/gshadow
gpasswd [-A user1,...] [-M user3,...] groupname
gpasswd [-rR] groupname
         -A 将groupname的主控权交给后面的用户(该群组管理员)
         -M 将某些账号加入这个群组中
         -r 将groupname密码移除
         -R 让groupname密码栏失效

gpasswd [-ad] user groupname
         -a 将某位用户加入到groupname这个群组中
         -d 将某位使用者移除groupname这个群组

# 查看linux中所有阻信息
vim /etc/group
cat /etc/group

# 查看linux中所有用户信息
cat /etc/passwd

# 查看是否支持ACL
dmesg | grep -i acl

# 设置ACL
setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名
         -m 设定后续的acl参数给文件使用,不可与-x合用
         -x 删除后续的acl参数,不可与-m合用
         -b 移除所有的ACL设定的参数
         -k 移除预设的ACL参数
         -R 递归设定ACL,也即包括子目录都会被设定
         -d 设定预设ACL参数,之对目录有效,在该目录新建的数据会引起此默认值
[u:[用户列表]:[rwx]]
[g:[群组名列表]:[rwx]]
[m:[rwx]] 针对有效权限设定
[d:[ug]:用户列表:[rwx]] 使用默认权限设定目录未来文件的ACL权限继承
setfacl -m u:vbird1:rx acl_test.txt
setfacl -x u:myuser1 /srv/projecta 取消某个账号的ACL时,不需要加上权限
setfacl -m u:pro3:- /srv/projecta  设定一个用户或群组没有任何ACL权限的语法中,在权限字段不留空必须用-代替
针对目录需要使用-R递归参数;阵地普通文件使用-m参数;删除使用-b

# 查看ACL
getfacl filename
        getfacl的选项几乎与setfacl相同
***************** 用户权限 *****************

***************** 文件,目录 *****************
# 是否能删除或重命名文件则由其父目录的权限设置所控制
# 对目录而言,读取权限则负责确定能否列出该目录中的内容;写入权限控制着在目录中创建,删除和重命名文件;执行权限实际控制了用户能否进入该目录;
# 文件类型:-普通文件;d目录;c字符设备文件;b块设备文件;s本地域套接口;p有名管道;l符号链接
# 4 SUID;2 SGID;1 SBIT
# SUID
  SUID权限仅对二进制程序有效
  执行者对于该程序需要具有x的可执行权限
  本权限仅在执行该程序的过程中有效
  执行者将具有该程序拥有者的权限
  可以让二进制程序的执行者拥有属主的权限
# SGID
   对二进制程序有用
   程序执行者对于该程序来说,需具备x的权限
   执行者在执行的过程中将会获得该程序群组的支持
   用户若对于此目录具有r与x的权限时,该用户能够进入此目录
   用户在此目录下的有效群组将会变成该目录的群组
   若用户在此目录下具有w的权限,则使用者所有建立的新文件群组与目录群组相同
   1.可以让二进制程序的执行者拥有属组的权限
   2.在某个目录中创建文件自动继承该目录的用户组(只可以对目录进行设置)
# SBIT 确保用户只能删除自己的文件
   只针对目录有效
   当用户对于此目录具有w,x权限,即具有写入权限时
   当用户在该目录下建立文件或目录时,仅有自己与root才有权力删除该文件

# 获取文件名
basename /etc/sysconfig/network

# 获取目录路径
dirname /etc/sysconfig/network

# 查看文件类型
file ~/.bashrc

# 语系编码转换
iconv --list
iconv -f 源编码 -t 新编码 filename [-o newfile]
      --list 列出iconv支持的语系数据
      -f from,后面接原本的编码格式
      -t to,后面接新编码格式
      -o file 如果要保留原本的文件,那么使用-o 新文件名,可以建立新编码文件

# 查看指令文件完整路径
which [-a] command
       -a 将所有由PATH目录中可以找到的指令均列出,而不止第一个被找到的指令名称

# 显示当前工作目录
pwd

# 改变目录
cd

# 列出文件和目录
ls
    -a 全部文件,连同隐藏文件(开头为.的文件)一起列出来
    -A 全部文件,连同隐藏文件,但不包括.与..这两个目录
    -d 仅列出目录本身,而不是列出目录内的文件数据
    -f 直接列出结果,而不进行排序
    -F 根据文件,目录等信息给与附加数据结构
        *:代表可执行文件 /:代表目录 =:代表socket文件 |:代表FIFO文件
    -h 将文件容量以人类较易读的方式(GB,KB)列出来
    -i 列出inode号码
    -l 长数据串行输出,包括文件的属性与权限等数据
    -n 列出UID与GID而非使用者与群组的名称
    -r 将结果反向输出
    -R 连同子目录内容一起列出来
    -S 以文件容量大小排序,而不是以文件名排序
    -t 以时间排序,而不是以文件名排序
    --color=never 不要依据文件特性给与颜色显示
    --color=always 显示颜色
    --color=auto   让系统自行依据设定来判断是否给与颜色
    --full-time    以完整时间模式(包括年,月,日,时,分)输出
    --time={atime,ctime} 输出access时间或改变权限属性时间(ctime)而非内容变更时间(modification time)

# 建立目录
mkdir
mkdir -p 帮助你直接将所需要的目录(包含上层目录)递归建立起来

# 删除目录(仅能删除空目录)
rmdir
rmdir -p 目录名称 连同上层空的目录也一起删除

# 建立空文件
mtime 当文件内容变更时就会更新这个时间
ctime 当文件权限与属性被更改就会更新这个时间
atime 当文件内容被读取就会更新这个时间
touch [-acdmt] 文件
       -a 仅修订access time
       -c 仅修改文件的时间,如果文件不存在则不建立新文件
       -d 后面可以接欲修订的日期而不用当前的日期,也可以使用--date="日期或时间"
       -m 仅修改mtime
       -t 后面可以接欲修订的时间而不用当前的时间,格式为YYYYMMDDhhmm

# 文件剪切
mv [-fiu] source destination
    -f force强制的意思,如果目标文件存在不会询问直接覆盖
    -i 若目标文件存在会询问是否覆盖
    -u 若目标文件存在且source较新时才会更新

# 复制文件
cp [-adfilprsu] source destination
    -a 相当于-dr --preserve=all的意思
    -d 若源文件为链接文件,则复制链接文件属性而非文件本身
    -f 强制,若目标文件已经存在且无法开启,则移除后再尝试一次
    -i 若目标文件已经存在,在覆盖时会先询问
    -l 进行硬链接的链接文件的建立,而非复制文件本身
    -p 连同文件的属性(权限,用户,时间)一起复制,而非使用默认属性(备份常用)
    -r 递归复制,用于目录的复制行为
    -s 复制成符号链接文件,即快捷方式文件
    -u destination比source旧才更新destination,或destination不存在的情况下才复制
    --preserve=all 除了-p的权限相关参数外,还加入SELinux的属性,links,xattr等也复制了
    注意: 如果源文件有两个以上,则最后一个一定要是目录

# 删除文件(在指令前加上\可以忽略掉alias指定选项)
rm [-fir] 文件或目录
    -f 就是force的意思,忽略不存在的文件不会出现警告信息
    -i 互动模式,在删除前会询问
    -r 递归删除

# 文件预设权限
umask
umask -S

# 设置文件所有权
chown lewis:root hello (属主:属组)
chown -R lewis iso/    (改变一个目录以及其下所有文件和目录的所有权)

# 设置文件属组
chgrp nogroup hello
chgrp -R nogroup iso/  (改变一个目录以及其下所有文件和目录的所有权)

# 修改权限命令(属主u;属组g;其他人o;所有人a)
chmod 777 文件名
chmod u+x hello
chmod a-x hello
chmod ug=rw,o=r hello
chmod o=u hello
chmod和chown命令用于修改目录时需要加上大写的-R参数表示递归操作

# 拷贝文件夹
cp -rf dir1 dir2

# 建立符号链接
ln [-sf] 源文件 目标文件
    -s 如果不加任何参数就进行连接那就是Hard Link,至于-siu是Symbol Link
    -f 如果目标文件存在时,就主动的将目标文件直接移除后再建立

# 查看文本文件
cat [-AbEnTv] 文件名
    -A 相当于-vET的整合选项,可列出一些特殊字符而不是空白而已
    -b 列出行号,仅针对非空白做行号显示;空白行不标行号
    -E 将结尾的断行字符$显示出来
    -n 打印出行号,连同空白行也会有行号,与-b选项不同
    -T 将[tab]按键以^I显示出来
    -v 列出一些看不出来的特殊字符

# 添加行号打印
nl [-bnw] 文件名
    -b 指定行号的方式有两种
    -b a 表示不论是否为空行同样列出行号
    -b t 空的那一行不列出行号(默认值)
    -n 列出行号的表示方法
    -n ln 行号在屏幕最左方显示
    -n rn 行号在自己字段的最右方显示,且不加0
    -n rz 行号在自己字段的最右方显示,且加0
    -w 行号字段占用的字节数

# 一页一页显示内容
more 123.txt
    空格键 下翻一页
    Enter  下翻一行
    /字符串 在这个显示的内容中向下搜索[字符串]这个关键字
    :f     立刻显示出文件名以及目前显示的行数
    q      退出
    b或[ctrl]-b 往回翻页,不过这个动作只对文件有用,对管线无用 

# 一页一页显示内容
less 123.txt
    空格键 下翻一页
    [pagedown] 下翻一页
    [pageup]   上翻一页
    /字符串 向下搜索[字符串]这个关键字
    ?字符串 向上搜索[字符串]这个关键字
    n 重复前一个搜索(与/或?有关)
    N 反向重复前一个搜索(与/或?有关)
    g 到第一行去
    G 到最后一行去
    q 退出

# 显示文件前几行
head [-n number] 文件

# 显示文件后几行
tail [-n number] 文件
      -n 后面接数字,代表显示几行的意思
      -f 表示持续侦测文件,要等到按下ctrl+c才会结束tail的侦测

# 查看非文本文件
od [-t TYPE] 文件
    -t 后面可以接各种类型的输出
    a 利用默认的字符输出
    c 使用ASCII字符输出
    d[size] 利用十进制输出数据,每个整数占用size bytes
    f[size] 利用浮点数输出数据,每个整数占用size bytes
    o[size] 利用八进制输出数据,每个整数占用size bytes
    x[size] 利用十六进制输出数据,每个整数占用size bytes

# 设置文件隐藏属性
chattr [+-=][ASacdistu] 文件或目录
        + 增加一个特殊参数,其他原本参数不动
        - 移除一个特殊参数,其他原本参数不动
        = 设定,且仅有后面接的参数
        A 当设定了A这个属性,若你有存取此文件(或目录时),访问时间atime将不会修改,可避免I/O较慢的机器过去存取磁盘(目前建议使用文件系统挂载参数处理这个项目)
        S 一般文件是异步写入磁盘的,加上S属性,当进行任何文件的修改,该修改会同步写入磁盘中
        a 这个文件只能增加数据,不能删除或修改数据,只有root才能设定这个属性
        c 自动将文件压缩,在读取的时候会自动解压,但是在存储的时候,将会先进行压缩后再存储
        d 当dump程序被执行时,设置d属性将可该文件(或目录)不会被dump备份
        i 让一个文件不能被删除,修改,设定连结也无法写入或新增数据,只有root才能设定这个属性
        s 如果这个文件被删除,他将会完全的移除硬盘空间,所以如果误删了,没办法救回
        u 与s相反,如果该文件被删除,则数据内容其实还在磁盘中,可以使用来救援该文件
        注意1: 属性常见的a与i设定值
        注意2: xfs文件系统仅支持AadiS
chattr +a test.txt
chattr -a test.txt

# 显示文件隐藏属性
lsattr [-adR] 文件或目录
        -a 将隐藏的属性也显示出来
        -d 如果接的是目录,仅列出目录本身的属性而非目录内的文件名
        -R 连同子目录的数据也一并显示

# 查找文件
find /usr/bin -name *.txt
              -type b块设备文件
                    c字符设备文件
                    d目录文件
                    f普通文件
                    p命名管道
                    l符号链接

# 快速定位文件
locate *.txt

# 在一些特定的目录中查找文件
whereis [-bmsu] 文件名
         -l 可以列出whereis会去查询的几个主要目录
         -b 只找binary格式的文件
         -m 只找在说明文件manual路径下的文件
         -s 只找source来源文件
         -u 搜索不在上述三个项目当中的其他特殊文件

# 利用数据库查找文件
locate [-ir] 文件名
        -i 忽略大小写
        -c 不输出文件名,仅计算找到的文件数量
        -l 仅输出几行
        -S 输出locate所使用的数据库文件的相关信息,包括该数据库记录的文件/目录数量等
        -r 后可接正规表示法的显示方式

updatedb 更新数据库

# 简单介绍命令文字
whatis uname

# 通过使用手册反查某个命令
apropos search

# 转移文件(if选项指定输入端的文件系统,of选项指定输出端)
dd if="input_file" of="output_file" bs="block_size" count="number"
   if input file
   of output file
   bs 规划一个block的大小,若未指定默认为512bytes(一个sector的大小)
   count 多少个bs的意思
dd if=/etc/passwd of=/tmp/passwd.bak

# 显示目前系统有被格式化的装置、uuid
blkid

# 文件比对
diff [-bBi] from-file to-file
      -b 忽略一行当中,仅有多个空白的差异(例如"about me"与"about   me"视为相同)
      -B 忽略空白行的差异
      -i 忽略大小写的不同

# 文件(字节)比对
cmp [-l] file1 file2
     -l 将所有不同点的字节处都列出来。因为cmp预设仅会输出第一个发现的不同点

# 查看所有进程允许打开的最大文件描述符(File Descriptor)数量
cat /proc/sys/fs/file-max

# 查看所有进程已经打开的文件描述符(File Descriptor)数量以及允许的最大数量
cat /proc/sys/fs/file-nr

# 查看单个进程允许打开的最大文件描述符(File Descriptor)数量
ulimit -n

#查看某个进程打开的文件描述符(File Descriptor)
ls -l /proc/{pid}/fd/
***************** 文件,目录 *****************

***************** 软件安装,卸载,更新 *****************
# 源码安装
1. 下载以及解压源码包文件
tar zxvf filename.tar.gz
2. 编译源码包代码(生成Makefile文件)
cd FileDirectory
./configure --prefix=/usr/local/program
3. 生成二进制安装程序
make
4. 运行二进制服务程序安装包
make install
5. 清理源码包临时文件
make clean

# 安装rpm包(软件的相关信息被写入到/var/lib/rpm/目录下的数据库文件中)
rpm -ivh RPM包全路径名称
    i=install 安装rpm包
    v=verbose 显示rpm当前正在执行的工作
    h=hash    通过打印一系列的#提醒用户当前的安装进度
    --force   忽略一切依赖和兼容问题强行安装软件包
    --nodeps  忽略软件包相关性冲突
    --justdb  由于RPM数据库破损或某些原因产生错误,可以使用这个更新软件在数据库内的信息
    --nosignature 略过数字签名的检查
    --prefix  软件安装到其他非正规目录

# 升级rpm包
rpm -Uvh RPM包全路径名称 没有安装过系统给与直接安装;安装过旧版则系统自动更新至新版
rpm -Fvh RPM包全路径名称 没有安装过系统不会安装;安装过旧版则系统自动更新至新版

# 查询linux中安装了那些rpm软件
rpm -qa 软件包名字(不是安装文件名字) -a选项可以列出当前系统上已经安装的所有软件包
    -q  仅查询,后面接的软件名称是否有安装
    -qa 列出所有已经安装在本机上的软件名称
    -qi 列出软件的详细信息,包括开发商,版本和说明等
    -ql 列出软件所有的文件与目录所在完整文件名
    -qc 列出软件所有的文件与目录所在完整文件名所有配置文件(找出/etc/下文件名而已)
    -qd 列出软件所有说明文件(找出与man有关的文件而已)
    -qR 列出与该软件相关的所有文件
    -qf 由后面接的文件名,找出该文件属于哪一个已安装的软件
    -q --scripts 列出是否含有安装后需要执行的脚本
    -c 查看配置文件信息rpm -q mysql-community-server -c
    -d 查看文档信息包括man帮助文档rpm -q mysql-community-server -d
    --filesbypkg 列出内部的全部文件rpm -q mysql-community-server --filesbypkg
    -i 查看包的信息包括安装时间rpm -q mysql-community-server -i
    -R 查看指定包要依赖的东西rpm -q mysql-community-server -R
    --scripts 查看指定包的一些安装卸载过程中的脚本rpm -q mysql-community-server --scripts
    --rebuilddb 重建数据库

查看全部包，根据安装日期倒序排列
rpm -qa --last
rpm -qa -last | grep mysql

# 查看rpm信息(未安装的也可查看)
rpm -qp[icdlR]

# rpm验证
rpm -V   后面加的是软件名称,若该软件所含的文件被改动过才会列出来
    -Va  列出目前系统上面所有可能被改动过的文件
    -Vp  后面加的是文件名,列出该软件内可能被改动过的文件
    -Vf  列出某个文件是否被改动过

# 卸载rpm包
rpm -e RPM软件包名称(不带有版本信息)
rpm -e --nodeps RPM包名称(不带有版本信息)
rpm -e -vv --test RPM软件包名称    -vv输出完整调试信息 --test模拟删除软件包的全过程

# 查看rpm包安装名称
rpm -qpi ./jdk-8u211-linux-x64.rpm

# 查看对应名称的软件安装生成了那些文件
rpm -ql jdk1.8

# SRPM
rpmbuild --rebuild   将后面的SRPM进行编译,打包
         --recompile 将后面的SRPM进行编译,打包,安装

# yum查询,安装,升级和移除功能
yum [option] [查询工作项目] [相关参数]
[option]:
-y 当yum要等待用户输入时,这个选项可以自动提供yes响应
--installroot=/some/path 将该软件安装在/some/path而不使用默认路径
[查询工作项目] [相关参数]
search 搜索某个软件名称或描述
list   列出目前yum所管理的所有软件名称与版本
info   同上,有点类似rpm -qai的执行结果
provides 从文件去搜索软件类似rpm -qf功能

yum install 后面接要安装的软件
yum update  后面接要升级的软件,若要整个系统都升级,就直接update即可
yum remove  移除软件
yum list installed | grep mysql 查看已经安装的软件

yum clean packages 将已下载的软件文件删除
yum clean headers  将下载的软件文件头删除
yum clean all      将所有软件数据都删除
yum whatprovides /usr/bin/sftp 查看sftp这个命令属于哪个软件包

yum自动下载RPM包及其所有依赖的包:
安装Downloadonly插件,以root身份运行以下命令:
yum install yum-plugin-downloadonly
此插件并不适用于yum groupinstall。默认情况下,这个插件将会下载仓库中最新可用的软件包。然而你可以通过指定版本号来下载某个特定的软件版本yum install --downloadonly --downloaddir=/root/mypackages/ httpd-2.2.6-40.el7
yum install --downloadonly <package-name> 默认情况下,这个命令将会下载并把软件包保存到/var/cache/yum/的rhel-{arch}-channel/packageslocation目录,不过你也可以下载和保存软件包到任何位置,你可以通过–downloaddir选项来指定
yum install --downloadonly --downloaddir=<directory> <package-name>
yum install --downloadonly --downloaddir=/root/mypackage/ tcpdump
yum install --downloadonly --downloaddir=/root/mypackage/ lrzsz

# yum软件群组功能
yum 
    grouplist 列出所有可使用的软件群组
    groupinfo 后面接group_name,了解该group内含的所有软件名
    groupinstall 安装一整租群组
    groupremove  移除某个软件群组

# 安装.deb软件
dpkg -i[nstall] [--force]

# 查看.deb软件已安装的软件包
dpkg -l | grep openssh

# 查看.deb软件安装了那些文件
dpkg -S openssh

# 卸载.deb软件
dpkg --remove openssh

# APT软件包工具:更新当前apt-get缓存中的软件包信息
apt-get update

# APT软件包工具:下载并安装软件包
apt-get install wesnoth

# APT软件包工具:下载并安装在本系统上已有的软件包的最新版本
apt-get upgrade wesnoth

# APT软件包工具:卸载特定的软件包
apt-get remove wesnoth

# APT软件包工具:下载特定的软件源代码
apt-get source wesnoth

# APT软件包工具:删除所有已下载的包文件
apt-get clean

# APT软件包工具:列出apt-get完整用法
apt-get -h

# APT软件包工具:搜索软件包列表中特定的软件包
apt-cache search wesnoth

# APT软件包工具:显示特定软件包的依赖关系
apt-cache depends wesnoth

# 配置apt-get:/etc/apt/sources.list
***************** 软件安装,卸载,更新 *****************

***************** 磁盘,分区,挂载 *****************
# 查看linux系统分区情况
fdisk -l
    IDE硬盘驱动器标识符为: hdx~  hd表明分区所在设备的类型这是指IDE硬盘。x为盘号  a为基本盘,b为基本丛属盘,c为辅助主盘,d为辅助丛属盘;~代表分区,前4个分区用数字1-4表示,它们是主分区或扩张分区,从5开始就是逻辑分区。
    SCSI硬盘驱动器标识符为: sd
fdisk /dev/sdb

# 查看文件系统整体磁盘使用量
df [-ahikHTm] 目录或文件名
    -a 列出所有的文件系统,包括系统特有的/proc等文件系统
    -k 以KBytes的容量显示各文件系统
    -m 以MBytes的容量显示各文件系统
    -h 以人们较易阅读的GBytes、Mbytes、KBytes等格式自行显示
    -H 以M=1000K取代M=1024K的进位方式
    -T 连同该partition的filesystem名称(例如xfs)也列出
    -i 不用磁盘容量,而以inode的数量来显示

df -h /etc 将/etc目录下可用的磁盘容量以易读的容量格式显示

# 评估文件系统的磁盘使用量
du [-ahskm] 文件或目录名称
    -a 列出所有的文件与目录容量,因为默认仅统计目录底下的文件量而已
    -h 以人们较易读的容量格式(G/M)显示
    -s 列出总量而已,而不列出每个各别的目录占用量
    -S 不包括子目录下的总计,与-s有点差别
    -k 以KBytes列出容量显示
    -m 以MBytes列出容量显示
du -ah --max-depth=1 /usr/local 显示文件夹、文件的大小

# 列出系统上所有的磁盘列表
lsblk [-dfimpt] [device]
       -d 仅列出磁盘本身,并不会列出该磁盘的分区数据
       -f 同时列出该磁盘内的文件系统名称
       -i 使用ASCII的线段输出,不要使用复杂的编码(在某些环境下很有用)
       -m 同时输出该装置在/dev下的权限数据(rwx数据)
       -p 列出该装置的完整文件名!而不是仅列出最后的名字
       -t 列出该磁盘装置的详细数据,包括磁盘队列机制、预读写的数据量大小

# 列出磁盘分区表类型与分区信息
parted [装置] [指令[参数]]
               新增分区 mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束
               显示分区 print
               删除分区 rm [partition]

parted /dev/sda unit mb print

# 磁盘分区
gdisk
fdisk

# 更新Linux核心的分区表信息
partprobe -s

# 查找系统CPU数量
grep 'processor' /proc/cpuinfo

# 文件系统检查
xfs_repair [-fnd] 装置名称
            -f 后面的装置其实是个文件而不是实体装置
            -n 单纯检查并不修改文件系统的任何数据(检查而已)
            -d 通常用在单人维护模式底下,针对根目录进行检查与修复动作！很危险不要随便使用

# 检查文件系统
fsck /dev/sda1 
                -p 会读取fstab文件来确定检查哪些文件系统

# 格式化
mkfs -t minix /dev/sdb1 Linux最早使用的文件系统
        ext3            ext3文件系统
        ext4            ext4文件系统
        msdos           FAT文件系统
mkfs -t ext4 -c /dev/sdb1 -c选项来检查指定设备上损坏的块
mkfs.xfs /dev/sdb1

# 初始化交换分区
mkswap /dev/sdb2

# 检查并激活交换分区
swapon /dev/sdb2

# 查看当前系统上存在的交换分区
swapon -s

# 检查文件系统
fsck -f /dev/sdb1 
                    -f 强制检查新的文件系统

# 挂载文件系统
mount 
      -a 依照配置文件/etc/fstab的数据将所有未挂载的磁盘都挂载上来
      -l 显示挂载以及Label名称
      -n 在默认的情况下,系统会将实际挂载的情况实时写入/etc/mtab中,以利其他程序运行。但某些情况下(例如单人维护模式)为了避免问题会刻意不写入。此时就需要使用-n选项
      -t 指明设备所使用的文件类型
      -r 只读模式挂载设备
      -w 读写模式挂载设备
      -o rw 可读写方式挂在
      --bind 将某个目录挂载到其他目录中去

mount -o remount,rw,auto / 将/重新挂载,并加入参数为rw与auto
mount -n -o remount,rw /

# 开机挂载/etc/fstab以及/etc/mtab


# 网络硬盘查看服务端导出的目录
showmount -e 10.171.37.1

# 取消挂载(如果硬盘分区已经挂载到文件系统中,那么在格式化之前必须用umount命令卸载该分区)
unmount -r 在umount在无法卸载文件系统的情况下尝试以只读方式重新载入
        -f 强制卸载!可用在类似网络文件系统(NFS)无法读取到的情况下
        -l 立刻卸载文件系统,比-f还强!
        -n 不更新/etc/mtab情况下卸载   

# 列出当前内核已经发现的USB设备
lsusb

# 软件磁盘阵列设定
mdadm --detail /dev/md0
mdadm --create /dev/md[0-9] --auto=yes --level=[015] --chunk=NK --raid-device=N --spare-devices=N /dev/sdx /dev/hdx...
      --create 建立RAID选项
      --auto=yes 决定建立后面接的软件磁盘阵列装置,也即/dev/md0,/dev/md1...
      --chunk=Nk 决定这个装置的chunk大小,也可以当成stripe大小,一般是64K或512K
      --raid-devices=N 使用几个磁盘(partition)作为磁盘阵列的装置
      --spare-devices=N 使用几个磁盘作为备用(spare)装置
      --level=[015] 设定这组磁盘阵列等级,支持很多,不过建议只要使用0,1,5即可
      --detail      后面所接的那个磁盘阵列装置的详细信息f
***************** 磁盘,分区,挂载 *****************

***************** 网络 *****************
# /etc/hosts Linux中hosts文件位置

# 显示当前系统上所有网络接口配置
ifconfig -a
ifconfig eth0 up      启动网络接口
ifconfig eth0 down 停止网络接口

# 增加一条路由
route add default gw 10.71.84.2
route add -net 10.62.74.0/24 gw 10.71.84.51
                        -net 表示后面紧跟的是网络地址
route add -host 10.62.74.4 gw 10.71.84.51
                        -host 表示后面紧跟的是主机地址

# 删除路由
route del default

# 检测主机连接
ping IP地址

# 查看本机路由表
route

# 显示数据包经过历程命令
traceroute IP地址

# 登录另一台Linux服务器(exit退出)
ssh -l root 192.168.150.139
ssh -l root -p 22 192.168.150.139

# 生成密钥对
ssh-keygen -t rsa
                    -t 指定密钥类型

# 基于SSH文件传输
sftp root@10.171.32.73

命令                      说明
rm                        删除文件和目录
rename                    修改文件名
put                       上传文件
get                       下载文件

# 基于SSH复制文件
scp root@10.171.33.221:/home/lewis/dump.tar.gz /srv/nfs_share/

scp的基本语法使用：scp -sercure copy （remote file copy program）
-P 指定端口,默认22,可忽略
-p 表示拷贝前后保持文件或目录属性
-r 递归,表示拷贝目录
-l 限制速度
推push
scp -P22 -rp /root/test.txt root@39.108.140.0:/root/
拉pull
scp -p22 -rp root@39.108.140.0:/root/test.txt ./

# 远程复制目录
scp -r /usr/local/mycat/ root@192.168.100.21:/usr/local/

# 追踪网络或插槽文件
netstat -[atunlp]
        -a 将目前系统上所有的联机、监听、Socket数据都列出来
        -t 列出tcp网络封包的数据
        -u 列出udp网络封包的数据
        -n 不以进程的服务名称,以端口号来显示
        -l 列出目前正在网络监听的服务
        -p 列出该网络服务的进程PID
netstat -tulnp

# 网络管理器
nmtui
systemctl restart network

# 查看网卡代号
nmcli connection show [网卡代号]
nmcli connection show
nmcli connection modify
nmcli connection up
#NAME 就是联机代号,通常与后面的网卡DEVICE会一样
#UUID 这个是特殊的装置识别,保留就好不要理他
#TYPE 网卡类型,通常就是以太网卡
#DEVICE 网卡名称

# 修改主机名
hostnamectl [set-hostname 你的主机名]
hostnamectl set-honame www.centos.vbird
cat /etc/hostname
***************** 网络 *****************

***************** 任务调度crontab *****************
# 设置任务
crontab -e

# 终止任务
crontab -r

# 列出当前有哪些任务
crontab -l
***************** 任务调度crontab *****************

***************** 压缩和解压 *****************
*.Z compress程序压缩文件
*.zip zip程序压缩文件
*.gz  gzip程序压缩文件
*.bz2 bzip2程序压缩文件
*.xz  xz程序压缩文件
*.tar tar程序打包数据,并没有压缩过
*.tar.gz tar程序打包文件,其中并且经过gzip压缩
*.tar.bz2 tar程序打包文件,其中并且经过bzip2压缩
*.tar.xz  tar程序打包文件,其中并且经过xz压缩

# 读取compress与gzip压缩文件
zcat service.gz
zmore service.gz
zless service.gz
zgrep

# 读取bzip2压缩文件
bzcat service.bz2
bzmore service.bz2
bzless service.bz2
bzgrep

# 读取xz压缩文件
xzcat service.xz
xzmore service.xz
xzless service.xz
xzgrep

# 读取

# gzip压缩
gzip [-cdtv#] 文件名
      -c 将压缩的数据输出到屏幕上,可以透过数据流重导向来处理
      -d 解压缩的参数
      -t 可以用来检验一个压缩文件的一致性~看看文件有无错误
      -v 可以显示出原文件/压缩文件案的压缩比等信息
      -# #为数字的意思,代表压缩等级,-1 最快压缩比最差、-9 最慢压缩比最好;预设是-6

gzip -9 -c services > services.gz 用最佳的压缩比压缩并保留原始文件
zgrep -n 'http'services.gz 找出http关键字在压缩文件中第几行
egrep 搜索压缩文件中的关键字

# gzip解压
gzip -d hello.tar.gz
gunzip hello.tar.gz

# 查看gzip压缩效果
gzip -l hello.tar.gz

# 测试gzip文件压缩的完整性
gzip -tv hello.tar.gz

# bzip2压缩
bzip2 [-cdkzv#] 文件名
       -c 将压缩过程产生的数据输出到屏幕上
       -d 解压缩的参数
       -k 保留源文件,而不会删除原始文件
       -z 压缩的参数(默认值可以不加)
       -v 可以显示出原文件/压缩文件案的压缩比等信息
       -# 与gzip同样的,都是在计算压缩比的参数:-9 最佳,-1 最快

# bzip2解压
bzip2 -d hello.tar.bz2
bunzip2 hello.tar.bz2

# 测试bzip2文件压缩的完整性
bzip2 -tv hello.tar.bz2

# xz压缩
xz [-dtlkc#] 文件名
    -d 解压缩
    -t 测试压缩文件的完整性,看有没有错误
    -l 列出压缩文件的相关信息
    -k 保留原始文件不删除
    -c 将压缩过程产生的数据输出到屏幕上
    -# 与gzip同样的,都是在计算压缩比的参数:-9 最佳,-1 最快

# xz解压

# tar打包
tar [-z|-j|J] [cv] [-f 新文件名] filename... 打包与压缩
tar [-z|-j|J] [tv] [-f 既有的tar文件名]       查看档名
tar [-z|-j|J] [xv] [-f 既有的tar文件名] [-C 目录] 解压缩
     -z 通过gzip进行压缩解压缩*.tar.gz
     -j 通过bzip2进行压缩解压缩*.tar.bz2
     -J 通过xz进行压缩解压缩*.tar.xz
     特别注意-z、-j、-J不可同时出现在一串指令列中
               -c 建立打包文件,可搭配-v来查看过程中被打包的档名
               -t 查看打包文件的内容有哪些文件名,重点在查看文件名就是了
               -x 解打包或解压缩,可以搭配-C在特定目录解开,特别注意-c、-t、-x不可同时出现在一串指令列中
               -v 在压缩解压缩的过程中,将正在处理的文件名显示出来
               -p 保留备份文件的原始权限与属性
               -P 保留绝对路径,也即允许备份文件中含有根目录存在之意
               --exclude=FILE 在压缩过程中,不要将FILE打包
               -f 后面要立刻接要被处理的文件名!建议-f单独写一个选项
               -C 在特定目录中解压,可以使用此选项
压缩:tar -zcvf test.tar.gz /test1 /test2
查看:tar -ztf test.tar.gz
解压:tar -zxvf test.tar.gz
***************** 压缩和解压 *****************

***************** VIM *****************
# 区块选择
v 字符选择,会将光标经过的地方反白选择
V 列选择,会将光标经过的地方反白选择
ctrl+v 区块选择,可以用长方形的方式选择
y 将反白的地方复制
d 将泛白的地方删除
p 将刚刚复制的区块粘贴

# 关键字补齐
ctrl+x->n 透过目前正在编辑的文件(文件的内容文字)作为关键词,予以补齐
ctrl+x->f 以当前目录内的文件名作为关键词,予以补齐
ctrl+x->o 以扩展名作为语法补充,以vim内建的关键词,予以补齐

命令                    操作
a                       在光标后插入 
i                       在光标所在位置插入
o                       在光标所在位置下一行插入
Esc                     进入命令模式
:                       进入行命令模式
h                       光标向左移动一格
l                       光标向右移动一格
J                       光标向下移动一格
k                       光标向上移动一格
^                       到行首
$                       到行尾
G                       到文件尾
Gg                      到文件头
W                       到下一个单词
B                       到前一个单词
ctrl+f                  上一页
ctrl+b                  下一页
x                       删除光标所在位置的字符
dd                      删除光标所在的行
D                       删除光标所在位置到行尾之间所有字符
d                       普通意义上的删除
yy                      复制光标所在的行
y                       普通意义的复制命令
P                       粘贴
u                       撤销
ctrl+R                  重做被撤销的操作
:w                      保存文件
:w filename             另存为filename
:q                      退出
:q!                     强行退出,放弃保存修改
:!cmd                不退出vim执行cmd命令
:r!cmd              不退出vim执行cmd命令并将cmd输出内容插入当前文本
:shell                切换到shell(并没有退出vim),用exit退出shell

# 向后搜索
/test

# 向前搜索
?test

# 大小写不敏感
set ignorecase

# 大小写敏感
set noignorecase

# 删除^M特殊字符(^M使用ctrl+v ctrl+m输入)
%s/^M$/ /g

# 语法高亮
syntax on

# 自动缩进
set autoindent

# 设置制表符长度
set shiftwidth=4
***************** VIM *****************

***************** Shell *****************
# 快捷键
ctrl+Insert 复制命令行内容
shift+Insert 粘贴命令行内容
ctrl+a 将光标移动到指令串最前面
ctrl+e 将光标移动到指令串最后面
ctrl+f 光标向右移动一个字符(相当于方向键右键)
ctrl+b 光标向左移动一个字符(相当于方向键左键)
ctrl+u 剪切(删除)光标前的字符
ctrl+k 剪切(删除)光标后的字符
ctrl+w 剪切(删除)光标前的一个单词
ctrl+y 粘贴使用ctrl+w,ctrl+u,ctrl+k快捷键擦除的文本
ctrl+c 中断终端正在执行的任务或者删除整行
ctrl+h 删除光标所在处的前一个字符(相当于退格键)
ctrl+d 退出当前Shell命令行
ctrl+r 搜索命令行使用过的历史命令记录
ctrl+g 从执行Ctrl+r的搜索历史命令模式退出
ctrl+p 查看上一个命令
ctrl+n 显示下一个命令
ctrl+r 搜索历史命令
ctrl+s 冻结终端
ctrl+q 解冻终端
ctrl+l 清除屏幕所有内容,并在屏幕最上面开始一个新行,等同clear命令
ctrl+z 暂停执行在终端运行的任务
esc+.(点) 获取上一条命令的最后的部分(空格分隔)
esc+t 颠倒光标所在处及其相邻单词的位置

#! /bin/bash

# 显示bash的PID
echo $$

# 显示上一个命令的回传值
echo $?

# 查看指令是否是内建方式
type [-tpa] name
            不加任何选项与参数时,type会显示name是外部指令还是bash内建指令
      -t    当加入-t参数时,type会将name以下面这些关键字显示他的意义
            file: 表示外部指令
            alias: 表示命令别名
            builtin: 表示bash内建指令
      -p    如果后面接的name为外部指令,会显示完整的文件名
      -a    由PATH变量定义的路径中,将所有含name的指令都列出来,包含alias

# 读取键盘输入的变量
read [-pt] variable
      -p 后面可以接提示符
      -t 后面可以接等待的秒数

# 声明变量类型
declare/typeset [-aixr] variable
                 -a 将后面名为variable的变量定义为数组
                 -i 将后面名为variable的变量定义为integer
                 -x 用法与export一样,将后面的variable变成环境变量
                 +x 取消环境变量
                 -r 将变量设定为readonly类型,该变量不可被更改内容,也不能unset
                 -p 可以单独列出变量的类型

# 变量的删除与替换
${变量#关键词}  若变量内容从头开始的数据符合关键词,则将符合最短数据删除
${变量##关键词} 若变量内容从头开始的数据符合关键词,则将符合最长数据删除
${变量%关键词}  若变量内容从尾开始的数据符合关键词,则将符合最短数据删除
${变量%%关键词} 若变量内容从尾开始的数据符合关键词,则将符合最长数据删除
${变量/旧字符串/新字符串}  若变量内容符合旧字符串,则第一个旧字符串会被新字符串取代
${变量//旧字符串/新字符串} 若变量内容符合旧字符串,则全部旧字符串会被新字符串取代

变量设定方式          str没有设定         str为空字符串        str已设定非空字符串
var=${str-expr}      var=expr           var=                var=$str
var=${str:-expr}     var=expr           var=expr            var=$str
var=${str+expr}      var=               var=expr            var=expr 
var=${str:+expr}     var=               var=                var=expr 
var=${str=expr}      str=expr           str不变             str不变 
                     var=expr           var=                var=$str
var=${str:=expr}     str=expr           str=expr            str不变
                     var=expr           var=expr            var=$str 
var=${str?expr}      expr输出至stderr    var=                var=$str
var=${str:?expr}     expr输出至stderr    expr输出至stderr    var=$str

# 查看当前Shell的环境变量
printenv

# 影响父Shell环境
source test.sh

# 影响子Shell环境
export count=5

# 注销变量
unset test

# 测试指令
test 
     -e 该档名是否存在
     -f 该档名是否存在且为文件
     -d 该档名是否存在且为目录
     -b 该档名是否存在且为block device装置
     -c 该档名是否存在且为character device装置
     -S 该档名是否存在且为Socket文件
     -p 该档名是否存在且为FIFO(pipe)文件
     -L 该档名是否存在且为链接文件
     -r 侦测该档名是否存在且具有可读权限
     -w 侦测该档名是否存在且具有可写权限
     -x 侦测该档名是否存在且具有可执行权限
     -u 侦测该档名是否存在且具有SUID属性 
     -g 侦测该档名是否存在且具有SGID属性
     -k 侦测该档名是否存在且具有Sticky bit属性
     -s 侦测该档名是否存在且为非空文件
test file1 -nt file2
           -nt 判断file1是否比file2新
           -ot 判断file1是否比file2旧
           -ef 判断file1与file2是否为同一文件,可用在判断hard link的判定上。主要意思在判定两个文件是否均指向同一个inode
test n1 -eq n2
        -eq 两个数值相等
        -ne 两个数值不等
        -gt n1大于n2 
        -lt n1小于n2
        -ge n1大于等于n2
        -le n1小于等于n2
test -z string 判断字符串是否为0?若string为空字符串则为true
     -n string 判断字符串是否为非0?若string为空字符串则为false
test str1==str2 判断字符串相等
test str1!=str2 判断字符串不相等
test -r filename -a -x filename
                 -a 与 
                 -o 或 
                 !  非

# shell追踪与debug
sh [-nvx] scripts.sh
    -n 不要执行script,仅查询语法的问题
    -v 再执行script前,先将scripts的内容输出到屏幕上
    -x 将使用到的script内容显示到屏幕上,这是很有用的参数
    -c string：命令从-c后的字符串读取

# 系统变量
$SHELL  默认Shell
$HOME  当前用户家目录
$IFS  内部字段分隔符
$LANG  默认语言
$PATH  默认可执行程序路径
$PWD  当前目录
$UID  当前用户ID
$USER  当前用户
$HISTSIZE  历史命令大小，可通过HISTTIMEFORMAT变量设置命令执行时间
$RANDOM  随机生成一个0至32767的整数
$HOSTNAME  主机名

# 特殊变量
$0  # 脚本自身名字
$?  # 返回上一条命令是否执行成功，0为执行成功，非0则为执行失败
$#  # 位置参数总数
$*  # 所有的位置参数被看做一个字符串
$@  # 每个位置参数被看做独立的字符串
$$  # 当前进程PID
$!  # 上一条运行后台进程的PID

# Shell格式
#！/bin/bash	脚本使用的解释器，通常用幻数“#！”指定
# Autho:	脚本作者
# Create_date	脚本创作时间
# Mail:		脚本作者联系方式
# Description:	脚本作用解释
# Version:	脚本的版本
***************** Shell *****************

***************** Crontab *****************
systemctl status atd 查阅一下atd目前的状态
systemctl enable atd 让这个服务开机就自动启动
systemctl restart atd 重启atd这个服务
/var/spool/at
/etc/at.allow
/etc/at.deny

/etc/crontab 系统例行任务,编辑完此文件后请重启crond服务systemctl restart crond
systemctl restart crond 重启crond这个服务
/var/spool/cron/smtsai 不要使用vim直接编辑文件
/var/log/cron
/etc/cron.allow
/etc/cron.deny

# 实际运行单一工作排程
at [-mldv] TIME
at -c 工作号码
    -m 当at的工作完成后,即使没有输出讯息,也以email通知用户该工作已完成
    -l at -l相当于atq,列出目前系统上面所有的该用户的at排程
    -d at -d相当于atrm,可以取消一个在at排程中的工作
    -v 可以使用较明显的时间格式栏出at排程中的任务栏表
    -c 可以列出后面接的该项工作的实际指令内容
    TIME 时间格式,这里可以定义出什么时候要进行at这项工作的时间,格式有:
    HH:MM ex>04:00
          在今日的HH:MM时刻进行,若该时刻已超过,则明天的HH:MM进行此工作
    HH:MM YYYY-MM-DD ex>04:00 2015-07-30
          强制指定某年某月某日的特殊时刻进行该工作
    HH:MM[am|pm] [Month] [Date] ex>04pm July 30
          也是一样的,强制在某年某月某日某时刻进行
    HH:MM[am|pm] + number[minutes|hours|days|weeks] 
          ex>now + 5 minutes ex>04pm + 3 days
          在某个时间点再加多少时间后才进行 

# 不需要指定时间,自动在系统空闲的时候执行指定的任务
batch

# 循环执行的例行性工作排程
crontab [-u username] [-l|-e|-r]
         -u 只有root才能进行这个任务,也即帮其他用户建立/移除crontab工作排程
         -e 编辑crontab工作内容
         -l 查阅crontab工作内容
         -r 移除所有的crontab工作内容,若仅要移除一项,请用-e去编辑

# 唤醒停机期间工作的任务
anacron [-sfn] [job]...
anacron -u [job]...
        -s 开始一连续的执行各项工作(job),会依据时间记录文件的数据判断是否进行
        -f 强制进行,而不去判断时间记录文件的时间戳
        -n 立刻进行未进行的任务,而不延迟等待时间
        -u 仅更新时间记录文件的时间戳,不进行任何工作
        job 由/etc/anacontab定义的各项工作名称
***************** Crontab *****************

***************** 管道命令 *****************
# 分割截取
cut -d '分割字符' -ffields
cut -c 字符区间
    -d 后面接分割字符,与-f一起使用
    -f 依据-d的分割字符将一段信息分区为数段,用-f取出第几段的意思
    -c 以字符的单位取出固定的字符区间

# 查找匹配截取
grep [-acinv] [--color=auto] '搜索字符串' filename
      -a 将binary文件以text文件的方式搜索
      -c 计算找到"搜索字符串"的次数
      -i 忽略大小写
      -n 输出行号
      -v 反向选择,即显示出没有"搜索字符串"内容的那一行
      --color=auto 可以将找到的关键词部分加上颜色的显示

grep [-A] [-B] [--color=auto] '搜索字符串' filename
      -A 后面可加数字,为after的意思,除了列出该行外,后续的n行业列出来
      -B 后面可加数字,为before的意思,除了列出该行外,前面的n行业列出来
      --color=auto 可将正确的那个截取的数据列出颜色

# 排序
sort [-fbMnrtuk] [file or stdin]
      -f 忽略大小写
      -b 忽略前导空格
      -M 以月份的名字来排序,例如JAN,DEC等等排序方法
      -n 使用纯数字进行排序(默认是以文字形态来排序的)
      -r 反向排序
      -u 就是uniq,相同的数据仅出现一行
      -t 分隔符,预设是用[tab]键来分隔
      -k 以那个区间来进行排序

# 去重
uniq [-ic]
      -i 忽略大小写
      -c 进行计数

# 计算输出信息的整体数据
wc [-lwm]
    -l 仅列出行
    -w 仅列出多少字(英文单字)
    -m 多少字符

# 双向重导向
tee [-a] file
     -a 以累加的方式,将数据加入file当中

# 删除替换文字
tr [-ds] SET1 ...
    -d 删除信息当中SET1这个字符串
    -s 取代掉重复的字符
last | tr '[a-z]' '[A-Z]' 将last输出信息中所有的小写变为大写

# tab转为对等的空格
col [-xb]
     -x 将tab键转为对等的空格键
     -b 

# 合并两个文件相同数据(注意:文件需要经过排序,否则比对的项目会被掠过)
join [-ti12] file1 file2
      -t join默认以空格分隔数据,并且比对第一个字段的数据,如果两个文件相同,则将两笔数据连成一行且第一个字段放在的第一个 
      -i 忽略大小写
      -1 代表第一个文件要用哪个字段来分析
      -2 代表第二个文件要用哪个字段来分析

# 合并两个文件相同数据
paste [-d] file1 file2
       -d 后面可以接分隔字符,预设是以tab来分割
       -  如果file部分写成-,表示来自standard input的资料的意思

# 将tab转成空格
expand [-t] file
        -t 后面可以接数字,一般来说一个tab键可以用8个空格取代。我们也可以自行定义一个tab键代表多少个字符

# 文件分区
split [-bl] file PREFIX
       -b 后面可以接欲分区成的文件大小,可加单位,例如b,k,m等 
       -l 以行数来进行分区
       PREFIX 代表前导符的意思,可作为分区文件的前导文字

# 参数替换
xargs [-0epn] command
       -0 如果输入的stdin含有特殊字符,例如`,\,空格键等字符时,这个-0参数可以将他还原成一般字符
       -e 这个是EOF的意思,后面可以接一个字符串,当xargs分析到这个字符串时,就会停止继续工作
       -p 在执行每个指令的argument时,都会询问
       -n 后面接次数,每次command指令执行时,要使用几个参数的意思
       当xargs后面没有接任何指令时,默认是以echo来进行输出的!

# 将数据进行取代、删除、新增、截取特定行
sed [-nefr] [动作]
     -n 使用安静模式。在一般sed的用法中,所有来自STDIN的数据一般都会被列出到屏幕上。但如果加上-n参数后,则只有经过sed特殊处理的那一行才会被列出
     -e 直接在指令列模式上进行sed的动作编辑
     -f 直接将sed动作写在一个文件内,-f filename则可以执行filename内的sed动作
     -r sed的动作支持的是延伸型正规表示法的语法(预设是基础正规表示法语法)
     -i 直接修改读取的文件内容,而不是由屏幕输出
    动作说明: [n1[,n2]]function
    n1,n2 不见得会存在,一般代表选择进行的行数,举例来说,如果我的动作是需要在10到20行之间,则10,20[动作行为]
    function有底下这些东西:
    a 新增,a的后面可以接字符串,而这些字符串会在新的一行出现
    c 取代,c的后面可以接字符串,而这些字符串可以取代n1,n2之间的行
    d 删除,因为是删除,所以d后面通常不接任何东西
    i 插入,i的后面可以接字符串,而这些字符串会在新的一行出现
    p 打印,也即将某个选择的数据印出。通常p会与参数sed -n一起运作
    s 取代,可以直接进行取代的工作。通常这个s的动作可以搭配正规表示法。例如1,20s/old/new/g就是啦
***************** 管道命令 *****************

***************** 防火墙iptables *****************
# iptables常用选项
iptables -F 清空规则链
               -P 设置默认策略
               -L 查看规则链
               -A 在规则链末尾加入新规则
               -I num 在规则链头部加入新规则
               -D num 从链中删除一条规则
               -s 匹配来源地址IP/MASK,加叹号"!"表示除这个IP外
               -d 匹配目标地址
               -i 网卡名称 匹配从这块网卡流入的数据
               -o 网卡名称 匹配从这块网卡流出的数据
               -p 匹配协议,如TCP、UDP、ICMP
               --dport num 匹配目标端口号
               --sport num 匹配来源端口号

查看已有的防火墙规则链: iptables -L
清空已有的防火墙规则链: iptables -F
把INPUT规则链的默认策略设置为拒绝: iptables -P INPUT DROP（规则链的默认拒绝动作只能是DROP不能是REJECT）
向INPUT链中添加允许ICMP流量进入策略规则: iptables -I INPUT -p icmp -j ACCEPT
删除规则链中的策略: iptables -D INPUT 1
保存防火墙策略: service iptables save
开放8080端口:
iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
service iptables save
/etc/rc.d/init.d/iptables restart
/etc/init.d/iptables status
/sbin/iptables -D INPUT 2 删除端口（2表示上面的num列）
***************** 防火墙iptables *****************

***************** 防火墙firewall-cmd *****************
使用firewall配置策略有两种模式:运行时模式（runtime）、永久模式（permanent）。运行时模式又称为当前生效模式,而且随着系统的重启会失效,它是默认的模式。而如果需要配置永久生效,就需要添加--permanent参数
注意的是永久模式配置的策略只有重启之后才能自动生效,如果想让配置的策略立即生效,需要手动执行firewall-cmd --reload 命令
配置文件说明:firewalld存放配置文件有两个目录,/usr/lib/firewalld/和/etc/firewalld/。前者存放了一些默认的文件,后者主要是存放用户自定义的数据

常用的区域名称以及策略规则:
trusted 允许所有的数据包
home    拒绝流入的流量,除非与流出的流量相关;而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关,则允许流量
internal 等同于home区域
work      拒绝流入的流量,除非与流出的流量数相关;而如果流量与ssh、ipp-client与dhcpv6-client服务相关,则允许流量
public    拒绝流入的流量,除非与流出的流量相关;而如果流量与ssh、dhcpv6-client服务相关,则允许流量
external 拒绝流入的流量,除非与流出的流量相关;而如果流量与ssh服务相关,则允许流量
dmz        拒绝流入的流量,除非与流出的流量相关;而如果流量与ssh服务相关,则允许流量
block      拒绝流入的流量,除非与流出的流量相关;
drop       拒绝流入的流量,除非与流出的流量相关;
firewall-cmd命令参数及作用
--get-default-zone                 查询默认的区域名称
--set-default-zone=区域名称 设置默认的区域使其永久生效
--get-zones                              显示可用的区域
--get-services                          显示预先定义的服务
--get-active-zones                  显示当前正在使用的区域与网卡名称
--add-source=                         将源自此IP或子网的流量导向指定的区域
--remove-source=                   不再将源自此IP或子网的流量导向某个指定区域
--add-interface=网卡名称       将源自该网卡的所有流量都导向某个指定区域
--change-interface=网卡名称  将某个网卡与区域进行关联
--list-all                                     显示当前区域的网卡配置参数、资源、端口以及服务等信息
--list-all-zones                          显示所有区域的网卡配置参数、资源、端口以及服务等信息
--add-service=服务名               设置默认区域允许该服务的流量
--add-port=端口号/协议           设置默认区域允许该端口的流量
--remove-service=服务名         设置默认区域不再允许该服务的流量
--remove-port=端口号/协议     设置默认区域不再允许该端口的流量
--reload                                      让"永久生效"的配置规则立即生效,并覆盖当前的配置规则
--panic-on                                  开启应急状况模式
--panic-off                                  关闭应急状况模式

# 查看防火墙状态
firewall-cmd --state
systemctl status firewalld

# 启动|停止|重启防火墙
systemctl start firewalld
systemctl stop firewalld
systemctl restart firewalld.service

# 查看当前使用的区域
firewall-cmd --get-default-zone
firewall-cmd --zone=public --query-service=ssh
firewall-cmd --zone=public --query-service=https

设置Https协议为永久允许
firewall-cmd --zone=public --add-service=https
firewall-cmd --permanent --zone=public --add-service=https
开放8080端口:
firewall-cmd --permanent --zone=public --add-port=8080/tcp
firewall-cmd --reload
***************** 防火墙firewall-cmd *****************

***************** 管理远程会话 *****************
yum install -y screen
screen -S 创建会话窗口
            -d 指定会话离线处理
            -r 恢复指定会话
            -x 一次性恢复所有会话
            -ls 显示当前已有的会话
            -wipe 删除无法使用的会话
screen -S backup
***************** 管理远程会话 *****************

***************** SFTP *****************
# 安装sftp命令
yum install openssh-clients

# 查看sftp这个命令属于哪个软件包
yum whatprovides /usr/bin/sftp

# 查看自己的公网出口IP地址
curl icanhazip.com
curl ifconfig.me
curl curlmyip.com
curl ip.appspot.com
curl ipinfo.io/ip
curl ipecho.net/plain
curl www.trackip.net/i

# 连接sftp利用私钥登录命令
sftp -oIdentityFile=私钥地址 -oPort=端口 用户名@ip
sftp -oIdentityFile=/root/.ssh/id_rsa -oPort=8001 ems@114.255.225.37

# sftp常用命令
ls 查看当前目录下文件
help 查看sftp支持哪些命令
cd 指定目录
pwd 查看当前目录
get xxx.txt 下载xxx文件
put xxx.txt 上传xxx文件
quit/bye/exit 退出sftp
***************** SFTP *****************

***************** 二进制文件 *****************
# 分析二进制可执行文件的依赖
ldd /bin/pwd

# 查看二进制文件的16进制编码
hexdump -C /bin/pwd | head

# 打印二进制文件中可显示的字符
strings /bin/pwd | head

# 查看ELF格式的文件信息
readelf -h /bin/pwd

# 查看目标文件或者可执行的目标文件的构成的GCC工具
objdump -d /bin/pwd | head

# 列出目标文件的符号
nm hello | tail
***************** 二进制文件 *****************

***************** awk *****************
在读取数据时,可设置表示输入记录分隔符的预定义变量RS(Record Separator)来改变每次读取的记录模式:
awk 'BEGIN{RS="\n"}'默认情况下使用\n换行符进行分隔读取
RS="":按段落读取
RS="\0":一次性读取所有数据,但有些特殊文件中包含了空字符\0
RS="^$":真正的一次性读取所有数据,因为非空文件不可能匹配成功
RS="\n+":按行读取,但忽略所有空行
使用语法:
1.awk [ -- ] program-text file ...
2.awk -f program-file [ -- ] file ...
3.awk -e program-text [ -- ] file ...
program-txt是awk命令行中的awk代码，一般使用单引号包围
-f program-file表示将awk代码写在文件中，然后使用-f选项去执行该文件
-e program-text也用于指定awk代码，如果要结合文件和命令行一起使用，必须使用-e和-f，不能使用(1)
***************** awk *****************