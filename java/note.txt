####################### env #######################
1. jdk环境变量设置
	JAVA_HOME: E:\ServerSoftware\Java\jdk1.8.0_141
	CLASSPATH: .;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\jre\lib\dt.jar
	Path:      在末尾加入 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin
开始运行输入cmd打开命令行窗口，输入java -version，显示版本1.7.0_51，输入javac -version，也显示1.7.0_51，说明JDK安装及环境变量配置成功。
2. tomcat环境变量设置
	CATALINA_HOME: E:\ServerSoftware\Java\apache-tomcat-9.0.0.M26

3. Spring框架下载地址: 
	https://repo.spring.io/libs-release-local/org/springframework/spring/

4. Maven环境变量设置
    MAVEN_HOME: D:\ProgramFile\Green\apache-maven-3.5.0
    Path:       在末尾加入 ;%MAVEN_HOME%\bin
    MAVEN_OPTS: -Xms512m -Xmx1024m
    中央仓库:   ping repo1.maven.org
	
	4.1 设置本地仓库路径: conf/settings.xml文件中找到<localRepository>标签
	4.2 在eclipse中配置Maven
		Window->Preferences->Maven->Installations->Add:
		Installation home: D:\Program\Green\64\apache-maven-3.5.2
		Installation name: apache-maven-3.5.2
		然后别忘了勾选我们自己的Maven。
	4.3 制定我们Maven仓库位置，也就是让eclipse知道我们的仓库在哪
		Window->Preferences->Maven->User Settings
		User Settings: D:\Program\Green\64\apache-maven-3.5.2\conf\settings.xml
	4.4 重构索引，即将仓库中的内容让eclipse加载一下
		Show View->Other->Maven Repositories->在Local Repository上右键点击Rebuild Index
		这样就能在eclipse local Repository中查看我们本地仓库的内容了
	4.5 设置全局的jdk，在setting.xml文件中的profiles元素下添加如下profile元素：
		<profile>  
			<id>jdk18</id>  
			<activation>  
				<activeByDefault>true</activeByDefault>  
				<jdk>1.8</jdk>  
			</activation>  
			<properties>  
				<maven.compiler.source>1.8</maven.compiler.source>  
				<maven.compiler.target>1.8</maven.compiler.target>  
				<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>  
			</properties>   
		</profile>
	4.6 设置局部的jdk，在项目的pom,xml文件中添加如下build元素：
		<build>  
			<plugins>  
				<plugin>  
					<groupId>org.apache.maven.plugins</groupId>  
					<artifactId>maven-compiler-plugin</artifactId>  
					<configuration>  
						<source>1.8</source>  
						<target>1.8</target>
						<encoding>UTF-8</encoding>  
					</configuration>  
				</plugin>  
			</plugins>  
		</build> 
####################### env #######################

####################### cmd #######################
# 编译Java程序(有依赖jar包)
javac -encoding UTF-8 -Djava.ext.dirs=./ -d . /root/.ssh/download/SFTPClientUtil.java

# 执行Java程序(有依赖jar包)
java -Djava.ext.dirs=./ SFTPClientUtil
####################### cmd #######################

####################### Java基础 #######################
# 除法运算
整数除法会直接砍掉小数,而不是进位

# 数值类型转换
从float和double转换为整数值时,小数位将被截断。若你想对结果进行四舍五入,可以使用java.lang.Math的round()方法

# 异或运算
1 ^ 1->0
0 ^ 0->0
0 ^ 1->1

# 按位非~
由于~是一元运算符,所以不可与=联合使用

# 移位运算
只能用于处理整数类型
左移位运算符<<能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）
右移位运算符有“正”、“负”值:若值为正,则在高位插入0;若值为负,则在高位插入1
无符号右移>>>,它使用了“零扩展”（zero extension）:无论正负,都在高位插入0
如果移动 char、byte 或 short,则会在移动发生之前将其提升为 int,结果为 int
移位可以与等号 <<= 或 >>= 或 >>>= 组合使用。左值被替换为其移位运算后的值。但是,当无符号右移与赋值相结合时,若将其与byte或short一起使用的话,则结果错误。取而代之的是,它们被提升为 int 型并右移,但在重新赋值时被截断结果为 -1

# Integer缓存范围
[-128, 127]

# Integer.toBinaryString
若将较小的类型传递给Integer.toBinaryString()时,类型将自动转换为int

# 最大值二进制表示
char c = 0xffff; //最大char型16进制值
byte b = 0x7f; //最大byte型16进制值;
short s = 0x7fff; //最大short型16进制值

# 表达式运行(隐式转型)
表达式中最大的数据类型是决定表达式结果的数据类型.float型和double型相乘,结果是double型的;int和long相加,结果是long型

# 换行
%n实现的可以忽略平台间差异而生成适当的换行符,但只有当你使用System.out.printf()或System.out.format()时;对于System.out.println(),我们仍然必须使用\n

# 内部类访问外部类对象
OuterClass.this;

# 创建内部类对象
OuterClass.Inner inner = outer.new Inner();

# Function命名规则
1.如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等
2.如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但基本 Supplier 类型例外
3.如果返回值为基本类型，则用 To 表示，如 ToLongFunction <T> 和 IntToLongFunction
4.如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator
5.如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）
6.如果接收的两个参数类型不同，则名称中有一个 Bi

# 死锁发生的四个必要条件
1.互斥,共享资源X和Y只能被一个线程占用
2.占有且等待,线程T1已经取得共享资源 X,在等待共享资源 Y 的时候,不释放共享资源 X
3.不可抢占,其他线程不能强行抢占线程T1占有的资源
4.循环等待,线程T1等待线程T2占有的资源,线程T2等待线程T1占有的资源,就是循环等待

# instanceof
null instanceof Object返回false

# 避免使用BigDecimal(double val)构造方法
BigDecimal bd = new BigDecimal(3.1415926D);
System.out.println(bd.toPlainString());
RESULT:3.14159260000000006840537025709636509418487548828125

# 格式化修饰符
%[argument_index$][flags][width][.precision]conversion

# Integer的Class对象并不是Number的Class 对象的子类
ERROR:Class<Number> clazz = int.class;

# RandomAccessFile类的模式设置
r	只支持读，任何有关写的操作将会抛出异常
rw	支持读和写，如果文件不存在，将尝试创建
rws	类似于"rw"，需要同步更新文件的内容或者元数据到底层存储设备上
rwd	类似于"rws"，与"rws"不同的在于没有对元数据的要求

# 序列化
1.实现Serializable接口
private static final long serialVersionUID = 1L;
2.实现Externalizable接口
public void writeExternal(ObjectOutput out){}
public void readExternal(ObjectInput out){}
3.给类添加方法
private void writeObject(ObjectOutputStream stream) throws IOException{
    stream.defaultWriteObject();
}
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException{
    stream.defaultReadObject();
}
4.序列化静态字段
public static void serializaStaticState(ObjectOutputStream os) throws IOException {
    os.writeInt(color);//要想序列化必须加入特定的方法在序列化时调用此方法
}
public static void deserializeStaticState(ObjectInputStream os) throws IOException {
    color = os.readInt();
}

# 元注解
@Target	表示注解可以用于哪些地方。可能的 ElementType 参数包括：
		CONSTRUCTOR：构造器的声明
		FIELD：字段声明（包括 enum 实例）
		LOCAL_VARIABLE：局部变量声明
		METHOD：方法声明
		PACKAGE：包声明
		PARAMETER：参数声明
		TYPE：类、接口（包括注解类型）或者 enum 声明
		TYPE_PARAMETER: 表示该注解能写在类型变量的声明语句中（如：泛型声明）
		TYPE_USE: 表示该注解能写在使用类型的任何语句中
@Retention	表示注解信息保存的时长。可选的 RetentionPolicy 参数包括：
		SOURCE：注解将被编译器丢弃
		CLASS：注解在 class 文件中可用，但是会被 VM 丢弃
		RUNTIME：VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息
@Documented	将此注解保存在 Javadoc 中
@Inherited	允许子类继承父类的注解
@Repeatable	允许一个注解可以被使用一次或者多次（Java 8）

# happens-before的规则
程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。
监视器锁规则（Monitor Lock Rule）：一个unLock操作在时间上先行发生于后面对同一个锁的lock操作。
volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作在时间上先行发生于后面对这个量的读操作。
线程启动规则（Thread Start Rule）：Thread对象的start()先行发生于此线程的每一个动作。
线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。
线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
对象终结规则（Finalizer Rule）：一个对象的初始化完成先行发生于它的finalize()方法的开始。
传递性（Transitivity）：A在B之前发生，B在C之前发生，那么A在C之前发生。

# 泛型
在JDK1.5之后,数据类型得到了扩充,出历史原始类型扩充了四种泛型类型:参数化类型(ParameterizedType)、类型变量类型(TypeVariable)、限定符类型(WildcardType)、泛型数组类型(GenericArrayType)

# HashMap初始化容量大小计算
(int)((float)expectedSize/0.75F + 1.0F)

# BigDecimal
1. 使用new BigDecimal("19.98")字符串构造函数初始化,不要使用double类型的构造函数
2. 比较相等不要使用equal,因为这个equals方法不仅要比较数值是否相同,还要比较精度是否相同
3. setScale(2,RoundingMode.HALF_UP)四舍五入

# show-busy-java-threads
https://github.com/oldratlee/useful-scripts/tree/master

# Java8获取UTC
LocalDateTime.now(ZoneId.of("Europe/London"));
LocalDateTime.now(ZoneOffset.of("Z"));

# 北京时间转美国时间
ZoneOffsetTransition zot = ZoneOffsetTransition.of(LocalDateTime.now().withNano(0),ZoneOffset.of("+8"),ZoneOffset.of("-6"));
System.out.println(zot.getDateTimeBefore());
System.out.println(zot.getDateTimeAfter());

1. 先用中国变换规则和中国时间计算出那一瞬间
ZoneRules chinaRules = ZoneId.of("Asia/Shanghai").getRules();
ZoneOffset chinaOffset = chinaRules.getOffset(chinaTime);
Instant instant = chinaTime.toInstant(chinaOffset);
2. 算出的这个瞬间instant是世界通用的，然后用它去计算芝加哥在这一瞬间的时间偏移量
ZoneRules usaRules = ZoneId.of("America/Chicago").getRules();
ZoneOffset usaOffset = usaRules.getOffset(instant);
3. 待转换的时间，转换前时间偏移量，转换后时间偏移量这三者都有了，就变成一个确定的情况了
ZoneOffsetTransition china2usa = ZoneOffsetTransition.of(chinaTime, chinaOffset, usaOffset);
china2usa.getDateTimeBefore();
china2usa.getDateTimeAfter();
####################### Java基础 #######################

####################### 阻塞队列 #######################
# BlockingQueue
是一个支持两个附加操作的队列。这两个附加的操作是：
1. 在队列为空时,获取元素的线程会等待队列变为非空
2. 当队列满时,存储元素的线程会等待队列可用

ArrayBlockingQueue	由数组结构组成的有界阻塞队列（最常用）
LinkedBlockingQueue	由链表结构组成的有界阻塞队列（最常用）注意：一定要指定大小
PriorityBlockingQueue	支持优先级排序的无界阻塞队列。默认自然升序排列
DelayQueue		支持延时获取元素的无界阻塞队列。
SynchronousQueue	不存储元素的阻塞队列（可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程）
LinkedTransferQueue	由链表结构组成的无界阻塞队列
LinkedBlockingDeque	由链表结构组成的双向阻塞队列（双向队列指的是可以从队列的两端插入和移出元素）

# 核心方法
方法\处理方式	抛出异常	返回特殊值	一直阻塞	超时退出
插入方法	add(e)		offer(e)		put(e)		offer(e,time,unit)
移除方法	remove()	poll()		take()		poll(time,unit)
检查方法	element()	peek()		不可用		不可用
####################### 阻塞队列 #######################

####################### 定时器 #######################
# Timer
1. Timer底层是使用单线程来处理多个Timer任务,这意味着所有任务实际上都是串行执行,前一个任务的延迟会影响到之后的任务的执行
2. 由于单线程的缘故,一旦某个定时任务在运行时,产生未处理的异常,那么不仅当前这个线程会停止,所有的定时任务都会停止
3. Timer任务执行是依赖于系统绝对时间,系统时间变化会导致执行计划的变更
####################### 定时器 #######################

####################### JVM #######################
# 虚拟机进程状况工具
jps [ options ] [hostid]
       -q 只输出LVMID,省略主类的名称
       -m 输出虚拟机进程 启动时传递给主类main()函数的参数
       -l   输出主类的全名,如果进程执行的是jar包,输出jar路径
       -v  输出虚拟机进程启动时JVM参数

# Java进程内线程堆栈信息
jstack [option] vmid
jstack [option] executable core
jstack [option] [server-id@]remote-hostname-or-ip
            -F 当正常输出的请求不被响应时,强制输出线程堆栈
            -l long listings,显示额外的锁信息;在发生死锁时用jstack -l pid来观察锁持有情况
            -m mixed mode,如果调用本地方法,可以显示C/C++堆栈信息(比如Native方法)

# 虚拟机统计信息监视工具
堆内存 = 年轻代 + 年老代 + 永久代
年轻代 = Eden区 + 两个Survivor区（From和To）
jstat [ option vmid [interval [s|ms] [count]] ]
vmid: 本地虚拟机进程VMID与LVMID一直;远程虚拟机进程VMID格式为:[protocol:][//]lvmid[@hostname[:port]/servername]
           -class                 监视类装载、卸载数量、总空间及类装载所耗费的时间
           -gc                      监视Java堆状况,包括Eden区、2个Survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息
           -gccapacity        监视内容与-gc基本相同,但输出主要关注Java堆各个区域使用到的最大和最小空间
           -gcutil                 监视内容与-gc基本相同,单输出主要关注已使用空间占总空间的百分比
           -gccause             与-gcutil功能一样,但是会额外输出导致上一次GC产生的原因
           -gcnew                监视新生代GC的状况
           -gcnewcapacity  监视内容与-gcnew基本相同,输出主要关注使用到的最大和最小空间
           -gcold                  监视老年代GC的状况
           -gcoldcapacity    监视内容与-gcold基本相同,输出主要关注使用到的最大和最小空间
           -gcpermcapacity 输出永久代使用到的最大和最小空间
           -compiler              输出JIT编译器编译过的方法、耗时等信息
           -printcompilation 输出已经被JIT编译的方法
各个列含义:
S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）
EC、EU：Eden区容量和使用量
OC、OU：年老代容量和使用量
PC、PU：永久代容量和使用量
YGC、YGT：年轻代GC次数和GC耗时
FGC、FGCT：Full GC次数和Full GC耗时
GCT：GC总耗时

# Java配置信息工具
jinfo [ option ] pid
           -flag 显示指定参数的值
           -sysprops 把虚拟机进程的System.getProperties()内容打印
jinfo -flag CMSInitiatingOccupancyFraction 49912

# Java内存映像工具(-XX:+HeapDumpOnOutOfMemoryError让虚拟机在OOM异常出现后自动生成dump文件)
jmap [option] pid
jmap [option] executable core
jmap [option] [server-id@]remote-hostname-or-ip
如果运行在64位JVM上,可能需要指定-J-d64命令选项参数
           -dump 生成Java堆转储快照;格式为:-dump:[live,]format=b,file=filename,其中live子参数说明是否只dump出存活的对象
           -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象,只在Linux/Solaris平台下有效
           -heap 显示Java堆详细信息,如使用哪种回收器、参数配置、分代状况等.只在Linux/Solaris平台下有效
           -histo 显示堆中对象统计信息,包括类、实例数量和合计容量
           -permstat 以ClassLoader为统计口径显示永久代内存状态,只在Linux/Solaris平台下有效
           -F 当虚拟机进程对-dump选项没有响应时,可使用这个选项强制生成dump快照.只在Linux/Solaris平台下有效
jmap -permstat pid
jmap -heap pid 查看进程堆内存使用情况
jmap -histo[:live] pid 查看堆内存中的对象数目、大小统计直方图
jmap -dump:format=b,file=dumpFileName pid把进程内存使用情况dump到文件中

# Java Heap Analysis Tool虚拟机堆转储快照分析工具(内置微型HTTP/HTML服务器)
jhat
示例:
jmap -dump:format=b,file=/tmp/dump.dat 21711
jhat -port 9998 /tmp/dump.dat 注意:如果dump文件太大,可能需要加上-J-Xmx512m参数指定最大堆内存
jhat -J-Xmx512m -port 9998 /tmp/dump.dat 然后就可以在浏览器中输入主机地址:9998查看了

# hprof(Heap/CPU Profiling Tool)展现CPU使用率,统计堆内存使用情况
java -agentlib:hprof[=options] ToBeProfiledClass
java -Xrunprof[:options] ToBeProfiledClass
javac -J-agentlib:hprof[=options] ToBeProfiledClass

# DEMO:找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息
1. 找出Java进程ID,部署应用名为mrf-center:
ps -ef | grep mrf-center | grep -v grep
2. 找出该进程内最耗费CPU的线程
ps -Lfp pid
ps -mp pid -o THREAD,tid,time
top -Hp pid TIME列就是各个Java线程耗费的CPU时间
3. 将线程ID转为十六进制
printf '%x\n' 21742
4. 堆栈信息中找出线程信息
jstack pid | grep 54ee
####################### JVM #######################

####################### Web #######################
# 去掉jsp过于的空格
web.xml中加入以下配置
<jsp-config>
	<jsp-property-group>
		<url-pattern>*.jsp</url-pattern>
		<trim-directive-whitespaces>true</trim-directive-whitespaces>
	</jsp-property-group>
</jsp-config>

# Content-Type的格式
type/subtype(;parameter)? type
以text开头的媒体格式类型：
text/html:HTML格式
text/plain:纯文本格式
text/xml:XML格式

以image开头的媒体格式类型：
image/gif:gif图片格式
image/jpeg:jpg图片格式
image/png:png图片格式

以application开头的媒体格式类型：
application/xhtml+xml:XHTML格式
application/xml:XML数据格式
application/atom+xml:Atom XML聚合格式 
application/json:JSON数据格式
application/pdf:pdf格式 
application/msword:Word文档格式
application/octet-stream:二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded:<form encType=””>中默认的encType,form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

上传文件之时使用的：
multipart/form-data:需要在表单中进行文件上传时,就需要使用该格式
####################### Web #######################

####################### Spring #######################
# 获取当前的代理
((LoginDaoImpl)AopContext.currentProxy()).findUser();

# 定时任务
默认情况下，Spring 将会生成一个单线程ScheduledExecutorService执行定时任务。所以一旦某一个定时任务长时间阻塞这个执行线程，其他定时任务都将被影响，没有机会被执行线程执行。
<task:annotation-driven  scheduler="myScheduler"/>
<task:scheduler id="myScheduler" pool-size="10"/>

spring.task.scheduling.pool.size=10
spring.task.scheduling.thread-name-prefix=task-test
通过上面的配置，Spring将会使用TaskScheduler子类ThreadPoolTaskScheduler，内部线程数为pool-size数量，这个线程数将会直接设置ScheduledExecutorService线程数量。
####################### Spring #######################