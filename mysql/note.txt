####################### CMD命令 #######################
# 启动MySQL服务
net start mysql

# 停止MySQL服务
net stop mysql

# 命令
mysql -h hostname -u username -p
      -h 主机名
      -u 用户名
      -p 密码(改字段后面的字符串和-p之间不能有空格)
      -P 端口号
      数据库名
      -e 执行sql语句(如果指定了该参数,将在登录后执行-e后面的命令或者sql语句并退出)

# 查看配置文件位置
which mysqld
->/usr/local/mysql/bin/mysqld
/usr/local/mysql/bin/mysqld --verbose --help | grep -A 1 'Default options'
####################### CMD命令 #######################

####################### 用户管理 #######################
# 创建用户
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 【PASSWORD】 'password'
             jeffrey   用户名
             localhost 主机名(默认为%即对所有的主机开放权限)
             【PASSWORD】使用哈希值设置密码(利用password('password')生成哈希值)

# 创建用户并授予权限
GRANT INSERT,DELETE,UPDATE,SELECT ON *.* TO 'username'@'%' IDENTIFIED BY 'password';

# 删除用户
DROP USER 'username'@'%'

# 修改密码(使用mysqladmin和GRANT命令设置密码均会加密密码不需要使用PASSWORD()函数)
mysqladmin -u username -h host -p password "newpwd";
SET PASSWORD=PASSWORD('newpwd'); 为了使更改生效需要重新启动MySQL或使用FLUSH PRIVILEGES;语句刷新权限,重新加载权限列表
SET PASSWORD FOR 'username'@'host'=PASSWORD('newpwd');  修改其他用户的密码
GRANT USAGE ON *.* TO 'username'@'host' IDENTIFIED BY 'newpwd';

# 重新加载权限
FLUSH PRIVILEGES;

# 忘记root密码
Windows系统下: 在命令行下切换到MySQL的bin目录
mysqld --skip-grant-tables
mysql-nt --skip-grant-tables
Linux系统下:
mysqld_safe --skip-grant-tables user=mysql
/etc/init.d/mysql start-mysqld --skip-grant-tables

# 查看权限
SHOW GRANTS FOR 'username'@'host'
####################### 用户管理 #######################

####################### 基本操作 #######################
# 查看警告信息
SHOW WARNINGS;

# 查看存储过程和函数
SHOW PROCEDURE|FUNCTION STATUS LIKE 'C%';
SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='sp_name';

# 查看存储过程和函数定义
SHOW CREATE PROCEDURE|FUNCTION sp_name;

# 查看视图
DESCRIBE 视图名;
SHOW TABLE STATUS LIKE 'viewname';
SHOW CREATE VIEW 视图名;
SELECT * FROM information_schema.views;

# 查看触发器
SHOW TRIGGERS;
SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME='trig_update';

# 关闭保护模式
SET SQL_SAFE_UPDATES=ON;
如果我们忘记在DELETE或者UPDATE语句中写WHERE条件,或者WHERE条件里面没有包含索引字段的话,这条语句的执行就会报错

# 查看当前MySQL进程状态
SHOW PROCESSLIST;

# 显式开启表锁
LOCK TABLE user READ/WRITE; 

# 关闭表锁
UNLOCK TABLES;

# 开启事务
所以事务开始时间点，分为两种情况：
1）START TRANSACTION时,是第一条语句的执行时间点,就是事务开始的时间点,第一条select语句建立一致性读的snapshot
2）START TRANSACTION WITH CONSISTENT SNAPSHOT时,则是立即建立本事务的一致性读snapshot,当然也开始事务了

# 查看事务
select * from information_schema.INNODB_TRX;

# 查看锁
select * from information_schema.INNODB_LOCKS;

# 查看锁等待
select * from information_schema.INNODB_LOCK_WAITS;

# 查看正在使用中的表
SHOW OPEN TABLES WHERE In_use > 0;

# 查看表锁、行锁
SHOW STATUS LIKE '%lock%'
SHOW GLOBAL STATUS LIKE "table_locks%";
SHOW STATUS LIKE 'innodb_row_lock%';

# 检查InnoDB的状态
show engine innodb status;

# 会在explain的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。
explain extended select * from film where id = 1;
show warnings;

# type列 这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。
依次从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

# 使用show profiles命令查看查询的详细耗时
set profiling=1;
执行SQL语句;
set profiling=0;
show profiles;
show profile cpu, block io for query 1;

# 区分大小写比较
SELECT BINARY 'a'='A';

# 修改MySQL结束符
DELIMITER //

# 连接MySQL服务器的次数
SHOW STATUS LIKE 'Connections';

# MySQL服务器的上线时间
SHOW STATUS LIKE 'Uptime';

# 慢查询次数
SHOW STATUS LIKE 'Slow_queries';

# 查询操作的次数
SHOW STATUS LIKE 'Com_select';

# 插入操作的次数
SHOW STATUS LIKE 'Com_insert';

# 更新操作的次数
SHOW STATUS LIKE 'Com_update';

# 删除操作的次数
SHOW STATUS LIKE 'Com_delete';

# 禁用/启用索引
ALTER TABLE tablename DISABLE KEYS;
ALTER TABLE tablename ENABLE KEYS;

# 禁用/启用唯一性检查
SET UNIQUE_CHECKS=0;
SET UNIQUE_CHECKS=1;

# 禁用/启用外键检查
SET FOREIGN_HKEYCHECKS=0;
SET FOREIGN_KEYCHECKS=1;

# 禁用/启用自动提交
SET AUTOCOMMIT=0;
SET AUTOCOMMIT=1;

# 查看datadir路径
SHOW VARIABLES LIKE '%datadir%';

# 查看二进制日志是否开启
SHOW VARIABLES LIKE '%log_bin%';
####################### 基本操作 #######################

####################### 数据库基本操作 #######################
# 创建数据库
CREATE DATABASE test_db CHARACTER SET utf8mb4;

# 删除数据库
DROP DATABASE test_db;

# 修改库的默认编码
ALTER DATABASE test CHARACTER SET utf8mb4;

# 查看数据库定义
SHOW CREATE DATABASE test_db;

# 查看系统支持的引擎类型
SHOW ENGINES;

# 查看默认存储引擎
SHOW VARIABLES LIKE 'default_storage_engine';

# 查看当前字符集
SHOW VARIABLES LIKE 'character_set_%';
####################### 数据库基本操作 #######################

####################### 数据表基本操作 #######################
# 创建数据表
CREATE TABLE tb_emp2
(
    id INT(11) PRIMARY KEY,
    name VARCHAR(25),
    deptId INT(11),
    salary FLOAT
);

# 查看数据表
SHOW TABLES;

# 查看创建表时的CREATE TABLE语句
SHOW CREATE TABLE 表名;

# 查看表结构
DESCRIBE 表名;

# 修改表名
ALTER TABLE 旧表名 RENAME 新表名;

# 修改字段数据类型
ALTER TABLE 表名 MODIFY 字段名 数据类型;

# 修改字段名(新数据类型不能为空)
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;

# 添加字段
ALTER TABLE 表名 ADD 新字段名 数据类型 约束条件 (FIRST|AFTER 已存在字段名)；
ALTER TABLE USERS ADD ALIAS VARCHAR(20) COMMENT '别名';

# 删除字段
ALTER TABLE 表名 DROP 字段名;
删除多个字段
ALTER TABLE users DROP COLUMN alias,DROP COLUMN age;

不修改名称 使用modify

# 修改字段
1.不修改名称使用modify
ALTER TABLE users MODIFY name VARCHAR(20) NOT NULL COMMENT '用户名';
2.修改名称使用change,格式是change要修改的名称 新名称
ALTER TABLE users CHANGE name username VARCHAR(20) NOT NULL COMMENT '用户名';

# 修改字段排列位置
ALTER TABLE 表名 MODIFY 字段名 数据类型 FIRST|AFTER 字段名;

# 更改表的存储引擎
ALTER TABLE 表名 ENGINE=InnoDB;

# 删除表的外键关系
ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名;

# 删除表
DROP TABLE [IF EXISTS] 表1,表2...;

# 添加索引
1.添加主键
ALTER TABLE users ADD PRIMARY KEY pk_id (`id`);
2.添加唯一索引
ALTER TABLE users ADD UNIQUE idx_name (`name`);
3.添加普通索引
ALTER TABLE users ADD INDEX idx_name (`age`);
4.添加全文索引
ALTER TABLE users ADD FULLTEXT (`列名`);
5.添加多列索引
ALTER TABLE users ADD INDEX idx_列名1_列名2_列名3 (`列名1`,`列名2`,`列名3`);
6.添加外键
ALTER TABLE 表名 ADD CONSTRAINT fk_引用id FOREIGN KEY(引用id) REFERENCES 被引用表名 (被引用id);
ALTER TABLE 表名 DROP FOREIGN KEY fk_引用id;

# 查看指定表中的创建的索引
SHOW INDEX FROM book;

# 查看索引使用情况
1. SHOW STATUS LIKE 'Handler_read%';
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数
handler_read_rnd_next:这个值越高，说明查询低效

Handler_read_first：索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）
Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）
Handler_read_next：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加
Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC
Handler_read_rnd：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救
Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引
2. SELECT * FROM sys.schema_unused_indexes;

# 开启优化器跟踪
SET SESSION optimizer_trace='enabled=on';
SELECT * FROM user WHERE phone = '15627231000' ORDER BY id LIMIT 1;
-- 查看优化器追踪
SELECT * FROM information_schema.optimizer_trace;
####################### 数据表基本操作 #######################

####################### 函数 #######################
# 返回当前系统的日期和时间
NOW()
SYSDATE()

# 字符串与日期转换
SELECT STR_TO_DATE('2018-9-1 14:25:12','%Y-%m-%d %H:%i:%s');
SELECT DATE_FORMAT(NOW(),'%Y-%m-%d %H:%i:%s');

# UTC时间
UTC_DATE()
UTC_TIME()
UTC_TIMESTAMP()

# UNIX时间戳
UNIX_TIMESTAMP()
UNIX_TIMESTAMP(date)

# 将UNIX时间戳转换为普通格式时间
FROM_UNIXTIME(date)

# 获取星期
DAYOFWEEK(date)  1:周日;2:周一...7:周六;
WEEKDAY(date)    0:周一;1:周二...6:周日;

# 获取一年中的第几天
DAYOFYEAR(date)

# 获取一个月中的第几天
DAYOFMONTH(d)

# 获取年份
YEAR(date)

# 获取季度
QUARTER(date)

# 获取月份(范围值1~12)
MONTH(date)

# 获取小时
HOUR(date)

# 获取分钟
MINUTE(date)

# 获取秒数
SECOND(date)

# 将时间转化为秒
TIME_TO_SEC(time)

# 将秒数转化为小时:分钟:秒
SEC_TO_TIME(seconds)

# 返回字符个数
CHAR_LENGTH(str)

# 返回字节长度(一个汉字3个字节,一个数字或字母一个字节)
LENGTH(str)

# 连接字符串
CONCAT(s1,s2...)

# 连接带分隔符的字符串
CONCAT_WS(x,s1,s2...)

# 获取指定长度的字符串
LEFT(s, length)
RIGHT(s,length)

# 填充字符串
LPAD(s1,length,s2)
RPAD(s1,length,s2)

# 删除空格
LTRIM(s)
RTRIM(s)
TRIM(s)

# 删除两端指定的字符串
TRIM(ss FROM s)

# 重复生成字符串
REPEAT(s,n)

# 替换字符串(使用字符串s2替换字符串s中所有的s1字符串)
REPLACE(s,s1,s2)

# 比较字符串大小
STRCMP(s1,s2)

# 获取子字符串
SUBSTRING(s,index,length)

# 获取子串的位置
LOCATE(ss,s)
POSITION(ss IN s)
INSTR(s,ss)

# IF函数
IF(expr,v1,v2)  (expr<>0 and expr<>NULL 返回v1否则返回v2)

# IFNULL函数(如果v1不为NULL返回v1,否则返回v2)
IFNULL(v1,v2)

# 获取MySQL版本号
VERSION()

# 查看当前用户连接次数
CONNECTION_ID()

# 显示当前所有的连接数和状态
SHOW PROCESSLIST (显示100条)
SHOW FULL PROCESSLIST

# 获取数据库名
DATABASE()
SCHEMA()

# 获取当前登录用户名称
USER()
CURRENT_USER()
SYSTEM_USER()

# 获取字符串的字符集
CHARSET(s)

# 获取字符串的排序方式
COLLATION(s)

# 获取最后一个自动生成的ID
LAST_INSERT_ID()

# 数字格式化(四舍五入方式保留小数点后n位,结果以字符串的形式返回;若n为0,返回结果不包含小数部分)
FORMAT(x,n)

# 重复执行指定的操作
BENCHMARK(count,expr)

# 改变字符集
CONVERT('string' USING latin1)

# 改变数据类型
CAST(x AS type)
CONVERT(x, type)

# 在分组查询中将分组中各个字段的值显示出来
GROUP_CONCAT(name)

# 分组查询后显示所有记录的总和
WITH ROLLUP

# 时间戳与时间相互转换
SELECT UNIX_TIMESTAMP('2020-01-11 09:53:32');
SELECT FROM_UNIXTIME(1578707612);
####################### 函数 #######################

####################### 备份还原 #######################
# 使用mysqldump命令备份
mysqldump -u username -h host -ppassword --databases dbname > filename.sql

# 还原数据库
mysql -u username -p [dbname] < filename.sql

# 导出表到文件
SELECT columnlist FROM table WHERE condition INTO OUTFILE 'filename'
mysqldump -T path dbname tablename -u root -p
mysql -u root -p [--vertical] [-html|-xml] --execute="SELECT * FROM person;" dbname > C:\person.txt

# 导入表
LOAD DATA INFILE 'filename' INTO TABLE tablename
mysqlimport -u root -p dbname filename.txt

# xtraBackup备份与还原工具
https://www.cnblogs.com/lijiaman/p/12291509.html
####################### 备份还原 #######################

####################### 日志 #######################
错误日志: 记录MySQL服务启动,运行或停止服务时出现的问题
查询日志: 记录建立的客户端连接和执行的预计
二进制日志: 记录所有更改数据的语句,可以用于数据复制
慢查询日志: 记录所有执行时间超过long_query_time的所有查询或不使用索引的查询

# 错误日志
SHOW VARIABLES LIKE 'log_error' 定位文件

# 慢查询日志
SHOW VARIABLES LIKE '%long_query%'
SHOW VARIABLES LIKE '%slow_query%'
SHOW VARIABLES LIKE '%log_queries_not_using_indexes%'
  修改慢查询日志输出方式
SHOW VARIABLES LIKE 'log_output';
SET  global log_output='table';
DESC mysql.slow_log;

# 查询日志
general_log=on
general_log_file=/usr/local/mysql/data/general_log

# 二进制日志
log-bin[=name]
binlog_format:参数决定了二进制日志文件的内容格式,其取值可以是statement,row或者是mixed
max_binlog_size:指定了单个二进制日志文件的最大值,如果超过该值,则产生新的二进制日志文件,后缀名+1,并记录到.index文件中,默认是1G
binlog_cache_size：对InnoDB来说,所有未提交的事务的二进制日志都会先写入到缓存中,只有当事务提交时将缓存中的二进制日志写入到日志文件中。而缓存的大小由binlog_cache_size决定，默认是32K。当一个线程开启一个事务时，会自动分配32K的大小的binlog缓存空间,当事务的记录大于32K大小的时候，则会把缓存中的日志写入到临时文件中，可以通过查询binlog_cache_disk_use参数查看写入到临时文件的次数
binlog_do_db/binlog_ignore_db:表示需要写入和忽略哪些库的二进制日志的写入,默认是空,表示所有数据库的二进制日志都要写入
log_slave_update:参数用来将从master上取得并执行的二进制日志写入到自己的二进制日志文件中去，通常在需要搭建master=>slave=>slave (一主多从，多主多从)架构的复制时，需要设置该参数

# 刷新日志
FLUSH LOGS
mysqladmin -u root -p flush-logs
mysqladmin refresh

# 查看是否开启binlog日志
SHOW VARIABLES LIKE 'log_%';
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index

开启binlog日志(在my.ini|my.cnf文件中添加如下内容):
# Binary Logging
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=D:\program\green\64\mysql-5.7.19-winx64\mysql-bin.log
# 设置日志格式
binlog-format=mixed

SHOW BINARY LOGS;
mysqlbinlog filename

# 删除所有二进制日志文件
RESET MASTER;

# 删除指定的二进制日志文件
PURGE MASTER|BINARY LOGS TO 'filename' 将删除文件名编号比指定文件名编号小的所有日志文件
PURGE MASTER|BINARY LOGS BEFORE '20130330' 将删除指定日期以前的所有日志文件

# 使用二进制日志还原数据库
mysqlbinlog --stop-date='2013-03-30' filename|mysql --user --ppass

# 开启/停止二进制日志功能
SET sql_log_bin={0|1}
####################### 日志 #######################

####################### explain语句解释 #######################
select_type: 指定所使用SELECT查询类型;其他可能取值有:PRIMARY,UNION,SUBQUERY等
table:       数据库读取的数据表名字,按读取的先后顺序排列
type:        指定本数据表与其他数据表之间的关联关系,可能取值有:system,const,eq_ref,ref,range,index和all
possible_keys: MySQL在搜索记录时可选用的各个索引
key:         实际选用的索引
key_len:     索引按字节计算的长度,key_len数据越小表示越快
ref:         指出关联关系中另一个数据表里的数据列的名字
rows:        在执行这个查询时预计会从数据表里读出的数据行个数
extra:       与关联操作有关的信息
####################### explain语句解释 #######################

####################### 锁 #######################
# 全局锁(让整个数据库处于只读状态)
FLUSH TABLES WITH READ LOCK;
FLUSH TABLES t WITH READ LOCK;

# 导数据之前启动一个事务,来确保拿到一致性快照
设置事务为RR模式,然后利用事务的特性,来获得一致性的数据,但是:在mysqldump运行期间,不能执行alter table,drop table,rename table,truncate table等等的DDL语句,因为一致性读和这些语句时无法隔离的
mysqldump --single-transaction

# 表锁
LOCK TABLES 表名 READ/WRITE;
UNLOCK TABLES

# 排他锁
SELECT col FROM table WHERE ID=1 FOR UPDATE;

# 共享锁
SELECT col FROM table WHERE ID=1 LOCK IN SHARE MODE;
####################### 锁 #######################

####################### 配置文件 #######################
[mysqld]
# GENERAL
datadir=/usr/local/mysql/data
socket=/usr/local/mysql/mysql.sock
pid_file=/usr/local/mysql/mysql.pid
user=mysql
port=3306
default_storage_engine=InnoDB
# INNODB
innodb_buffer_pool_size=
innodb_log_file_size=
innodb_file_per_table=1
inno_flush_method=0_DIRECT
# MYISAM
key_buffer_size=
# LOGGING
log_error=/usr/local/mysql/mysql-error.log
slow_query_log=/usr/local/mysql/mysql-slow.log
# OTHER
tmp_table_size=32M
max_heap_table_size=32M
query_cache_type=0
query_cache_size=0
max_connections=
thread_cache=
table_cache=
open_files_limit=65535
[client]
socket=/usr/local/mysql/mysql.sock
port=3306
####################### 配置文件 #######################

####################### 用户权限 #######################
特别需要注意,在MySQL中账号由两部分组成:
1.user
2.host
即使user相同,只要host不同,也会被认为是不同账号
默认情况下,创建的用户host为'%',这是一个匹配符,跟模糊查询里的意思一样,表示匹配所有

# 创建用户
CREATE USER [用户名] IDENTIFIED BY '[密码]';

# 删除用户
DROP USER 用户名;
DELETE FROM mysql.user WHERE user='用户名' AND host='%';

# 修改密码
SET PASSWORD FROM '用户名' @host=password('新密码');
UPDATE mysql.user SET password=password('新密码') WHERE user='用户名' AND host='%';

# 设置用户权限
将所有数据库上的所有权利都授予通过本机连接的VIP用户
GRANT ALL ON *.* TO vip@'127.0.0.1';
将数据库books上的所有权利都授予所有连接的vip用户
GRANT ALL PRIVILEGES ON books.* TO vip@'%';
将books数据库上的users表的访问权限开发给vip用户;
GRANT select ON books.users TO vip@'%';
WITH GRANT POTIONS的意思是可以给vip给予权限给别的用户
GRANT ALL ON *.* TO vip@'%' WITH GRANT POTIONS;

# 设置权限后要刷新权限
FLUSH PRIVILEGES;
####################### 用户权限 #######################

####################### 恢复数据 #######################
1. 确认数据库是否开启binlog日志
SHOW VARIABLES LIKE 'log_%';
查看以下几行的内容:
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index
2. 开启binlog日志
在my.ini文件中添加如下内容
# Binary Logging
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=D:\program\green\64\mysql-5.7.19-winx64\mysql-bin.log
# 设置日志格式
binlog-format=mixed
3. 查看最新的binlog日志文件
SHOW MASTER STATUS;
4. 查看 binlog 日志文件
SHOW BINLOG EVENTS IN 'mysql-bin.000001';
5. 使用mysqlbinlog恢复二进制日志文件
NOTE:如果是恢复数据库,则不需要带上数据库名称
mysqlbinlog binlog日志文件 --start-position 初始偏移量的位置 --stop-position 结束偏移量的位置 | mysql -u root -p 数据库名称;
例:
mysqlbinlog d:\Mysql-binlog\mysql-bin.000043 --start-position 710 --stop-position 996 | mysql -u root -p pingtouge;
####################### 恢复数据 #######################