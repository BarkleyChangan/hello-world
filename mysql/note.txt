####################### CMD命令 #######################
# 启动MySQL服务
net start mysql

ps -ef | grep mysqld
./mysqld_safe &

# 停止MySQL服务
net stop mysql
./mysqladmin -u root -p shutdown

# 登录命令
mysql -h hostname -u username -p
      -h 主机名
      -u 用户名
      -p 密码(改字段后面的字符串和-p之间不能有空格)
      -P 端口号
      数据库名
      -e 直接在外面交互式查看数据库里面的东西，而不用登录到数据库里面

# 使用mysql.sock登录
mysql.sock是mysql的主机和客户机在同一Host(物理服务器)上的时候,使用unix domain socket做为通讯协议的载体,比TCP快
1.新建user.root.cnf文件
[client]
user=root
password=Server2008
socket=/usr/local/mysql/mysql.sock
2.使用如下命令登录:
mysql --defaults-extra-file=../conf/user.root.cnf

# 查看配置文件位置
which mysqld
->/usr/local/mysql/bin/mysqld

/usr/local/mysql/bin/mysqld --verbose --help | grep -A 1 'Default options'
->Default options are read from the following files in the given order:
->/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf 
->2020-05-13 09:24:35 14082 [Note] Binlog end
->2020-05-13 09:24:35 14082 [Note] Shutting down plugin 'MyISAM'
->2020-05-13 09:24:35 14082 [Note] Shutting down plugin 'CSV'

# 字符集
SET NAMES 'charset_name';不过这里需要大家特别注意,SET names语句并不会改变客户端的默认字符集
该语句和下边三个语句等效：
SET character_set_client = charset_name;
SET character_set_results = charset_name;
SET character_set_connection = charset_name;

通过执行SHOW VARIABLES LIKE 'character%'命令搞清楚：
character_set_client：服务器是怎样认为客户端发送过来的请求是采用何种字符集编码的
character_set_connection：服务器在运行过程中会采用何种字符集编码请求中的字符
character_set_result：服务器会将响应使用何种字符集编码后再发送给客户端的
####################### CMD命令 #######################

####################### 用户管理 #######################
# 创建用户
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 【PASSWORD】 'password'
             jeffrey   用户名
             localhost 主机名(默认为%即对所有的主机开放权限)
             【PASSWORD】使用哈希值设置密码(利用password('password')生成哈希值)
NOTE:在MySQL5.7中user 表的password已换成了authentication_string
NOTE:password()加密函数已经在8.0.11中移除了,可以使用MD5()函数代替

# 创建用户并授予权限
GRANT INSERT,DELETE,UPDATE,SELECT ON *.* TO 'username'@'%' IDENTIFIED BY 'password';

# 删除用户
SELECT User, Host FROM mysql.user;

DROP USER [IF EXISTS] USER_ACCOUNT [, USER_ACCOUNT] ...
DROP USER 'username'@'%';
DELETE FROM mysql.user WHERE user='用户名' AND host='%';

# 修改密码(使用mysqladmin和GRANT命令设置密码均会加密密码不需要使用PASSWORD()函数)
mysqladmin -u username -h host -p password "newpwd";
SET PASSWORD=PASSWORD('newpwd'); 为了使更改生效需要重新启动MySQL或使用FLUSH PRIVILEGES;语句刷新权限,重新加载权限列表
SET PASSWORD FOR 'username'@'host'=PASSWORD('newpwd');  修改其他用户的密码
GRANT USAGE ON *.* TO 'username'@'host' IDENTIFIED BY 'newpwd';

# 重新加载权限
FLUSH PRIVILEGES;

# 忘记root密码
Windows系统下: 在命令行下切换到MySQL的bin目录
mysqld --skip-grant-tables
mysql-nt --skip-grant-tables
Linux系统下:
mysqld_safe --skip-grant-tables user=mysql
/etc/init.d/mysql start-mysqld --skip-grant-tables

# 查看权限
SHOW GRANTS FOR 'username'@'host'
####################### 用户管理 #######################

####################### 基本操作 #######################
MySQL数据目录:
|- ib_buffer_pool  // 保存缓冲池中页面的表空间ID和页面ID，用于重启恢复缓冲池
|- ib_logfile0        // redo log磁盘文件1
|- ib_logfile1        // redo log磁盘文件2,默认情况下重做日志存在磁盘的这两个文件中,循环的方式写入重做日志
|- ibdata1            // 系统表空间文件
|- ibtmp1            // 默认临时表空间文件,可通过innodb_temp_data_file_path属性指定文件位置
|- mysql/
|- mysql-bin.000001  // bin log文件
|- mysql-bin.000001  // bin log文件
|- mysql-bin.index    // bin log文件索引
|- mysqld.local.err    // 错误日志
|- mysqld.local.pid   // mysql进程号
|- performance_schema/  // performance_schema数据库
|- sys/  // sys数据库
|- test/  // 数据库文件夹
    |- db.opt  // test数据库配置文件,包含数据库字符集属性
    |- t.frm    // 数据表元数据文件,不管是使用独立表空间还是系统表空间,每个表都对应有一个
    |- t.ibd    // 数据库表独立表空间文件,如果使用的是独立表空间,则一个表对应一个ibd文件,否则保存在系统表空间文件中

# 连接字符串
jdbc:mysql://localhost:3306/test_db?characterEncoding=utf8&useSSL=false&useServerPrepStmts=true&cachePrepStmts=true&fserverTimezone=Asia/Shanghai&rewriteBatchedStatements=true&autoReconnect=true

# 修改参数
SET @@global.read_buffer_size=524288;
SET @@session.read_buffer_size=524288;

# 计算数据表数据量大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'M') FROM TABLES WHERE table_schema='szw' AND table_name='temp_table';

# 查看警告信息
SHOW WARNINGS;

# 查看存储过程和函数
SHOW PROCEDURE|FUNCTION STATUS LIKE 'C%';
SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='sp_name';

# 查看存储过程和函数定义
SHOW CREATE PROCEDURE|FUNCTION sp_name;

# 查看视图
DESCRIBE 视图名;
SHOW TABLE STATUS LIKE 'viewname';
SHOW CREATE VIEW 视图名;
SELECT * FROM information_schema.views;

# 查看触发器
SHOW TRIGGERS;
SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME='trig_update';

# 关闭保护模式
SET SQL_SAFE_UPDATES=ON;
如果我们忘记在DELETE或者UPDATE语句中写WHERE条件,或者WHERE条件里面没有包含索引字段的话,这条语句的执行就会报错

# 查看当前MySQL进程状态
SHOW PROCESSLIST;

# 显式开启表锁
LOCK TABLE user READ/WRITE; 

# 关闭表锁
UNLOCK TABLES;

# 查看锁
select * from information_schema.INNODB_LOCKS;
lock_id:锁ID
lock_trx_id:事务ID
lock_mode:锁模式
lock_type:锁的类型,表锁还是行锁
lock_table:要加锁的表
lock_index:锁的索引
lock_space:InnoDB存储引擎表空间的ID号
lock_page:被锁住页的数量,若是表锁则该值为NULL
lock_rec:被锁住行的数量,若是表锁则该值为NULL
lock_data:被锁住行的主键值,若是表锁则该值为NULL

# 查看锁等待
select * from information_schema.INNODB_LOCK_WAITS;

# 查看正在使用中的表
SHOW OPEN TABLES WHERE In_use > 0;

# 查看表锁、行锁
SHOW STATUS LIKE '%lock%'
SHOW GLOBAL STATUS LIKE "table_locks%";
SHOW STATUS LIKE 'innodb_row_lock%';

# 检查InnoDB的状态
show engine innodb status;
Log sequence number:当前的LSN
Log flushed up to:刷新到重做日志文件的LSN
Last checkpoint at:刷新到磁盘的LSN

# 会在explain的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。
explain extended select * from film where id = 1;
show warnings;

# type列 这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。
依次从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

# 使用show profiles命令查看查询的详细耗时
set profiling=1;
执行SQL语句;
set profiling=0;
show profiles;
show profile cpu, block io for query 1;

# 区分大小写比较
SELECT BINARY 'a'='A';

# 修改MySQL结束符
DELIMITER //

# 连接MySQL服务器的次数
SHOW STATUS LIKE 'Connections';

# MySQL服务器的上线时间
SHOW STATUS LIKE 'Uptime';

# 慢查询次数
SHOW STATUS LIKE 'Slow_queries';

# 查询操作的次数
SHOW STATUS LIKE 'Com_select';

# 插入操作的次数
SHOW STATUS LIKE 'Com_insert';

# 更新操作的次数
SHOW STATUS LIKE 'Com_update';

# 删除操作的次数
SHOW STATUS LIKE 'Com_delete';

# 禁用/启用索引
ALTER TABLE tablename DISABLE KEYS;
ALTER TABLE tablename ENABLE KEYS;

# 禁用/启用唯一性检查
SET UNIQUE_CHECKS=0;
SET UNIQUE_CHECKS=1;

# 禁用/启用外键检查
SET FOREIGN_HKEYCHECKS=0;
SET FOREIGN_KEYCHECKS=1;

SET FOREIGN_KEY_CHECKS=0;
SET FOREIGN_KEY_CHECKS=1;

# 禁用/启用自动提交
SET AUTOCOMMIT=0;
SET AUTOCOMMIT=1;

# 定位:配置文件my.cnf路径
./mysql --help | grep my.cnf

# 定位:datadir路径
SHOW VARIABLES LIKE '%datadir%';

# 查看二进制日志是否开启
SHOW VARIABLES LIKE '%log_bin%';

# 字符排序规则collation
字符集+语言名称+后缀
_ai   Accent-insensitive 口音不敏感
_as  Accent-sensitive 口音敏感
_ci   Case-insensitive 大小写不敏感
_cs   Case-sensitive 大小写敏感
_bin Binary 二进制排序
对于是ci后缀的collation(大小写不敏感)也意味着Accent-insensitive(口音不敏感)。同理对于是cs后缀的collation(大小写敏感)也意味着Accent-sensitive(口音敏感)

# 将数据库、表、列的字符编码、collation改为utf8md4、utf8mb4_unicode_ci
# For each database:
ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;
# For each table:
ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
# For each column:
ALTER TABLE table_name CHANGE column_name column_name VARCHAR(LENGTH) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
# 修复和优化所有的表以免出现一些莫名其妙的错误
REPAIR TABLE table_name;
OPTIMIZE TABLE table_name;
####################### 基本操作 #######################

####################### 数据库基本操作 #######################
# SQL模式
SQL模式主要分两类:语法支持类和数据检查类
1.语法支持类
ONLY_FULL_GROUP_BY:对于GROUP BY聚合操作,如果在SELECT中的列、HAVING或者ORDER BY子句的列没有在GROUP BY中出现,那么这个SQL是不合法的
ANSI_QUOTES:启用 ANSI_QUOTES后,不能用双引号来引用字符串,因为它被解释为识别符,作用与`一样,设置它以后update t set f1="" …,会报Unknown column ‘’ in field list这样的语法错误
PIPES_AS_CONCAT:将||视为字符串的连接操作符而非或运算符,这和Oracle数据库是一样的,也和字符串的拼接函数CONCAT()相类似
NO_TABLE_OPTIONS:使用SHOW CREATE TABLE时不会输出MySQL特有的语法部分,如ENGINE,这个在使用mysqldump跨DB种类迁移的时候需要考虑
NO_AUTO_CREATE_USER:字面意思不自动创建用户。在给MySQL用户授权时,我们习惯使用GRANT … ON … TO dbuser顺道一起创建用户。设置该选项后就与oracle操作类似,授权之前必须先建立用户
2.数据检查类
NO_ZERO_DATE:认为日期0000-00-00非法,与是否设置后面的严格模式有关
a、如果设置了严格模式,则NO_ZERO_DATE自然满足。但如果是INSERT IGNORE或UPDATE IGNORE,0000-00-00依然允许且只显示warning
b、如果在非严格模式下,设置了NO_ZERO_DATE,效果与上面一样,0000-00-00允许但显示warning;如果没有设置NO_ZERO_DATE,no warning,当做完全合法的值
c、NO_ZERO_IN_DATE情况与上面类似,不同的是控制日期和天,是否可为0,即2010-01-00是否合法
NO_ENGINE_SUBSTITUTION:使用ALTER TABLE或CREATE TABLE指定ENGINE时,需要的存储引擎被禁用或未编译该如何处理。启用NO_ENGINE_SUBSTITUTION时,那么直接抛出错误;不设置此值时,CREATE用默认的存储引擎替代,ATLER不进行更改,并抛出一个warning
STRICT_TRANS_TABLES:启用严格模式。注意STRICT_TRANS_TABLES不是几种策略的组合,单独指INSERT、UPDATE出现少值或无效值该如何处理
a、前面提到的把‘’传给int,严格模式下非法,若启用非严格模式则变成0,产生一个warning
b、Out Of Range,变成插入最大边界值
c、当要插入的新行中,不包含其定义中没有显式DEFAULT子句的非NULL列的值时,该列缺少值

-- 查看 MySQL 版本
SELECT VERSION();
-- 查看 sql_mode
SELECT @@sql_mode;
SET sql_mode='STRICT_TRANS_TABLES';

# 创建数据库
CREATE DATABASE test_db CHARACTER SET utf8mb4;

# 删除数据库
DROP DATABASE test_db;

# 修改库的默认编码
ALTER DATABASE test CHARACTER SET utf8mb4;

# 查看数据库定义
SHOW CREATE DATABASE test_db;

# 查看系统支持的引擎类型
SHOW ENGINES;

# 查看默认存储引擎
SHOW VARIABLES LIKE 'default_storage_engine';

# 查看当前字符集
SHOW VARIABLES LIKE 'character_set_%';

# 定期优化重建数据库
mysqlcheck -o –all-databases 会让 ibdata1 不断增大。真正的优化仅仅有重建数据表结构：
CREATE TABLE mydb.mytablenew LIKE mydb.mytable;
INSERT INTO mydb.mytablenew SELECT * FROM mydb.mytable;
ALTER TABLE mydb.mytable RENAME mydb.mytablezap;
ALTER TABLE mydb.mytablenew RENAME mydb.mytable;
DROP TABLE mydb.mytablezap;

# 获取插入的自增ID
SELECT LAST_INSERT_ID();
####################### 数据库基本操作 #######################

####################### 数据表基本操作 #######################
# 创建数据表
CREATE TABLE tb_emp2
(
    id INT(11) PRIMARY KEY,
    name VARCHAR(25),
    deptId INT(11),
    salary FLOAT
);

# 查看数据表
SHOW TABLES;

# 查看表的统计信息
SHOW TABLE STATUS FROM mybatis;

# 查看表的字段
SHOW COLUMNS FROM 数据表;

# 查看创建表时的CREATE TABLE语句
SHOW CREATE TABLE 表名;

# 查看表结构
DESCRIBE 表名;

# 修改表名
ALTER TABLE 旧表名 RENAME 新表名;

# 修改字段数据类型
ALTER TABLE 表名 MODIFY 字段名 数据类型;

# 修改字段名(新数据类型不能为空)
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;

# 添加字段
ALTER TABLE 表名 ADD 新字段名 数据类型 约束条件 (FIRST|AFTER 已存在字段名)；
ALTER TABLE USERS ADD ALIAS VARCHAR(20) COMMENT '别名';

# 删除字段
ALTER TABLE 表名 DROP 字段名;
删除多个字段
ALTER TABLE users DROP COLUMN alias,DROP COLUMN age;

不修改名称 使用modify

# 修改字段
1.不修改名称使用modify
ALTER TABLE users MODIFY name VARCHAR(20) NOT NULL COMMENT '用户名';
2.修改名称使用change,格式是change要修改的名称 新名称
ALTER TABLE users CHANGE name username VARCHAR(20) NOT NULL COMMENT '用户名';

# 修改字段排列位置
ALTER TABLE 表名 MODIFY 字段名 数据类型 FIRST|AFTER 字段名;

# 更改表的存储引擎
ALTER TABLE 表名 ENGINE=InnoDB;

# 删除表的外键关系
ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名;

# 删除表
DROP TABLE [IF EXISTS] 表1,表2...;

# 添加索引
1.添加主键
ALTER TABLE users ADD PRIMARY KEY pk_id (`id`);
2.添加唯一索引
ALTER TABLE users ADD UNIQUE idx_name (`name`);
3.添加普通索引
ALTER TABLE users ADD INDEX idx_name (`age`);
4.添加全文索引
ALTER TABLE users ADD FULLTEXT (`列名`);
5.添加多列索引
ALTER TABLE users ADD INDEX idx_列名1_列名2_列名3 (`列名1`,`列名2`,`列名3`);
6.添加外键
ALTER TABLE 表名 ADD CONSTRAINT fk_引用id FOREIGN KEY(引用id) REFERENCES 被引用表名 (被引用id);
ALTER TABLE 表名 DROP FOREIGN KEY fk_引用id;
NOTE:InnoDB存储引擎会自动对外键添加索引,删除外键上的索引会抛出异常

# 查看指定表中的创建的索引
SHOW INDEX FROM book;
Cardinality值非常关键,优化器根据这个值来判断是否使用索引,这个值并非实时更新,这是一个大概值,如果需要更新Cardinality的值使用ANALYZE TABLE t;

# 修复索引(会记录binlog日志)
ANALYZE TABLE book;

# 重建主键索引
ALTER TABLE T ENGINE=InnoDB;

# 查看索引使用情况
1. SHOW STATUS LIKE 'tableName%';
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数
handler_read_rnd_next:这个值越高，说明查询低效

Handler_read_first：索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）
Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）
Handler_read_next：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加
Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC
Handler_read_rnd：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救
Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引
2. SELECT * FROM sys.schema_unused_indexes;

# 开启优化器跟踪
1.查看优化器跟踪是否状态
SHOW VARIABLES LIKE '%optimizer_trace%';
2.开启tracing (默认是关闭的):
SET SESSION optimizer_trace="enabled=on";
3.执行查询语句
SELECT ...; 
4.查询trace json文件
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
5.完成后关闭trace
SET SESSION optimizer_trace="enabled=off";


# 驱动表和被驱动表
1.当连接查询没有where条件时，左连接查询时前面的表是驱动表，后面的表是被驱动表右连接查询时相反;内连接查询时,哪张表的数据较少哪张表就是驱动表
2.当连接查询有where条件时,带where条件的表是驱动表,否则是被驱动表
####################### 数据表基本操作 #######################

####################### 函数 #######################
# 返回当前系统的日期和时间
NOW()
SYSDATE()

# 字符串与日期转换
SELECT STR_TO_DATE('2018-9-1 14:25:12','%Y-%m-%d %H:%i:%s');
SELECT DATE_FORMAT(NOW(),'%Y-%m-%d %H:%i:%s');

# UTC时间
UTC_DATE()
UTC_TIME()
UTC_TIMESTAMP()

# UNIX时间戳
UNIX_TIMESTAMP()
UNIX_TIMESTAMP(date)

# 获取星期
DAYOFWEEK(date)  1:周日;2:周一...7:周六;
WEEKDAY(date)    0:周一;1:周二...6:周日;

# 获取一年中的第几天
DAYOFYEAR(date)

# 获取一个月中的第几天
DAYOFMONTH(d)

# 获取年份
YEAR(date)

# 获取季度
QUARTER(date)

# 获取月份(范围值1~12)
MONTH(date)

# 获取小时
HOUR(date)

# 获取分钟
MINUTE(date)

# 获取秒数
SECOND(date)

# 将时间转化为秒
TIME_TO_SEC(time)

# 将秒数转化为小时:分钟:秒
SEC_TO_TIME(seconds)

# 返回字符个数
CHAR_LENGTH(str)

# 返回字节长度(一个汉字3个字节,一个数字或字母一个字节)
LENGTH(str)

# 连接字符串
CONCAT(s1,s2...)

# 连接带分隔符的字符串
CONCAT_WS(x,s1,s2...)

# 获取指定长度的字符串
LEFT(s, length)
RIGHT(s,length)

# 填充字符串
LPAD(s1,length,s2)
RPAD(s1,length,s2)

# 删除空格
LTRIM(s)
RTRIM(s)
TRIM(s)

# 删除两端指定的字符串
TRIM(ss FROM s)

# 重复生成字符串
REPEAT(s,n)

# 替换字符串(使用字符串s2替换字符串s中所有的s1字符串)
REPLACE(s,s1,s2)

# 比较字符串大小
STRCMP(s1,s2)

# 获取子字符串
SUBSTRING(s,index,length)

# 获取子串的位置
LOCATE(ss,s)
POSITION(ss IN s)
INSTR(s,ss)

# IF函数
IF(expr,v1,v2)  (expr<>0 and expr<>NULL 返回v1否则返回v2)

# IFNULL函数(如果v1不为NULL返回v1,否则返回v2)
IFNULL(v1,v2)

# 获取MySQL版本号
VERSION()

# 查看当前用户连接次数
CONNECTION_ID()

# 显示当前所有的连接数和状态
SHOW PROCESSLIST (显示100条)
SHOW FULL PROCESSLIST

# 获取数据库名
DATABASE()
SCHEMA()

# 获取当前登录用户名称
USER()
CURRENT_USER()
SYSTEM_USER()

# 获取字符串的字符集
CHARSET(s)

# 获取字符串的排序方式
COLLATION(s)

# 获取最后一个自动生成的ID
LAST_INSERT_ID()

# 数字格式化(四舍五入方式保留小数点后n位,结果以字符串的形式返回;若n为0,返回结果不包含小数部分)
FORMAT(x,n)

# 重复执行指定的操作
BENCHMARK(count,expr)

# 改变字符集
CONVERT('string' USING latin1)

# 改变数据类型
CAST(x AS type)
CONVERT(x, type)

# 在分组查询中将分组中各个字段的值显示出来
GROUP_CONCAT(name)

# 分组查询后显示所有记录的总和
WITH ROLLUP

# 时间戳与时间相互转换
SELECT UNIX_TIMESTAMP('2020-01-11 09:53:32');
将UNIX时间戳转换为普通格式时间:
SELECT FROM_UNIXTIME(System.currentTimeMillis()/1000);

# 返回参数中的第一个非空表达式
SELECT COALESCE(NULL,'N/A') FROM dual;
SELECT COALESCE(NULL,NULL,3) FROM dual;
####################### 函数 #######################

####################### 备份还原 #######################
# 使用mysqldump命令备份
1.-B --databases            指定多个库。增加建库语句和use语句(提示:备份一个表的时候不要加-B,要不然所有表都会出来，就会报错)
2.--compact                  去掉注释，适合调试输出
3.-A --all-databases      备份所有库
4.-F                                刷新binlog日志
5.--master-data[=value] 增加binlog日志文件名及对应的位置点;当value为1时转储文件中记录CHANGE MASTER TO语句,当value为2时CHANGE MASTER TO语句被注释
6.-x --lock-all-tables     全局的读锁,会阻止对所有表的写入操作,对所有架构的所有表上锁
7.-l                                 该锁不会阻止读,也不会阻止新的数据插入
8.-d                               只备份表结构
9.-t                                只备份数据
10.--signle-transaction 适合innodb事务数据库备份,导数据之前就会启动一个事务来确保拿到一致性视图;对于MyISAM这种不支持事务的引擎,如果备份过程中有更新,总是只能取到最新的数据,那么就破坏了备份的一致性,这时我们就需要使用FTWRL命令了
11.--lock-tables             适合MyISAM存储引擎,依次每个架构中的表上锁,只能保证每个架构下表备份的一致性
12.--routines(-R)            备份存储过程和函数
13.--triggers                   备份触发器
14.--hex-blob                 将BINARY,VARBINARY,BLOG,BIT列类型备份为十六进制的格式
15.--tab=path                产生TAB分割的数据文件,对于每张表mysqldump创建一个包含CREATE TABLE语句的table_name.sql文件和包含数据的tbl_name.txt
16.--where='condition' 导出给定条件的数据

mysqldump -h host -uroot -ppassword --master-data=2 --default-character-set=utf8 --single-transaction -B dbname | gzip > /opt/back/mysqlbak_$(date +%F).sql.gz
mysqldump -h host -uroot -ppassword --master-data=2 --default-character-set=utf8 --single-transaction -B dbname test_db | gzip > /opt/mysql.bak.sql.gz 备份多个库
-- 全量压缩备份
mysqldump -h host -uroot -p111111 --default-character-set=utf8 --single-transaction -F -B dbname -e | gzip > /backup/mysql_backup_`date +%F`.sql.gz
--表结构和数据分离
mysqldump -h host -uroot -ppassword --master-data=2 --default-character-set=utf8 --single-transaction --tab='/usr/local/mysql/data/backup' -B dbname;
--导入
mysql -uroot -pServer2008 < test_backup.sql

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参--single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
前提就是引擎要支持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时候FTWRL命令了就派上用场了。
为什么我们不用SET GLOBAL readonly=true 的命令让全库处于只读的状态呢？
注意:这是生产上严厉禁止的,主要有如下两个原因：
1.在某些系统中,readonly的值会被用来做其他逻辑,比如用来判断一个库是主库还是备库。毫无疑问修改global变量的方式影响面更大。
2.在异常处理机制上存在差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，很容易造成生产事故。

# 使用mysqldump命令全量备份
mysqldump -h127.0.0.1 -uroot -pServer2008 -P3306 --master-data=2 --single-transaction --events --routines --databases testdb > /mysql/backup/testdb.sql
注意:必须要添加--master-data=2,这样才会备份集里面mysqldump备份的终点位置

#使用mysqldump命令全量恢复
mysql -uroot -pServer2008 testdb < /mysql/backup/testdb.sql

# 使用MySQL的binlog增量恢复
mysqlbinlog增量恢复方式
    基于时间点恢复
        (1)指定开始时间到结束时间mysqlbinlog mysqlbin.000005 --start-datetime='2020-02-25 01:10:46' --stop datetime='2020-02-25 03:10:46' -r time.sql
        (2)指定开始时间到文件结束mysqlbinlog mysqlbin.000005 --start-datetime='2020-02-25 01:10:46' -d esen -r time.sql
        (3)从文件开头到指定结束时间mysqlbinlog mysqlbin.000005 --stop-datetime='2020-02-25 03:10:46' -d esen -r time.sql
    基于位置点的增量恢复
        (1)指定开始位置到结束位置mysqlbinlog mysqlbin.000005 --start-position=510 --stop-position=1312 -r pos.sql
        (2)指定开始位置到文件结束mysqlbinlog mysqlbin.000005 --start-position=510 -r pos.sql
        (3)从文件开始位置到指定结束位置mysqlbinlog mysqlbin.000005 --stop-position=1312 -r pos.sql

使用mysqlbinlog进行增量日志恢复最重要的就是确定待恢复的起始位置(start-position)和终止位置(stop-position),起始位置(start-position)是我们执行全被之后的位置,而终止位置则是故障发生之前的位置
1.确认start-position
cat testdb.sql |grep "CHANGE MASTER"
-- CHANGE MASTER TO MASTER_LOG_FILE='master-bin.000044', MASTER_LOG_POS=8526828
备份到了44号日志的8526828位置,那么恢复的起点可以设置为:44号日志的8526828
2.确认stop-position
接下来确认要恢复的终点位置,即执行"DROP DATABASE testdb"之前的位置,需要到binlog里面确认
mysqlbinlog -v master-bin.000054 | grep -i "drop database testdb"
3.保存到文本便于搜索
mysqlbinlog -v master-bin.000054 > master-bin.txt
4.确认drop database之前的位置为:54号文件的9019487
5.确定了开始结束点执行增量恢复
开始:44号日志的8526828
结束:54号文件的9019487
这里分为3条命令执行,起始日志文件涉及到参数start-position参数,单独执行;中止文件涉及到stop-position参数,单独执行;中间的日志文件不涉及到特殊参数,全部一起执行
起始日志文件:mysqlbinlog --start-position=8526828 /mysql/binlog/master-bin.000044 | mysql -uroot -pServer2008
中间日志文件:mysqlbinlog /mysql/binlog/master-bin.000045 /mysql/binlog/master-bin.000046 /mysql/binlog/master-bin.000047 /mysql/binlog/master-bin.000048 /mysql/binlog/master-bin.000049 /mysql/binlog/master-bin.000050 /mysql/binlog/master-bin.000051 /mysql/binlog/master-bin.000052 /mysql/binlog/master-bin.000053 | mysql -uroot -pServer2008
终止日志文件:mysqlbinlog --stop-position=9019487 /mysql/binlog/master-bin.000054 | mysql -uroot -pServer2008

# 分库备份sh脚本
#!/bin/bash

MYUSER="root"
MYPASS="guoke123"
MYLOG="mysql -u$MYUSER -p$MYPASS -e"
MYDUMP="mysqldump -u$MYUSER -p$MYPASS -x -F"
DBLIST=$($MYLOG  "show databases;" | sed 1d | grep -Ev 'info|mysq|per|sys')
DIR=/backup
[ ! -d $DIR ] && mkdir $DIR
cd $DIR

for dbname in $DBLIST
do
    TABLIST=$($MYLOG "show tables from $dbname;" | sed 1d)
    for tabname in $TABLIST
    do
        mkdir -p $DIR/$dbname
        $MYDUMP $dbname $tabname  --events |gzip > $DIR/${dbname}/${tabname}_$(date +%F_%T).sql.gz
    done
done

# 还原数据库
1. mysql> source test1.sql; 恢复test1表
2. /usr/local/mysql5.7/bin/mysql --socket=/tmp/mysql.sock --port=3306 -uroot -p -e "use rec ; source  test1.sql;"
3. mysql -uroot -p < /opt/mysql_test1.sql         #备份时加-B参数恢复方法
    mysql -uroot -p test < /opt/mysql_test1.sql  #备份时没加-B参数恢复方法

# 使用MySQL的binlog增量恢复
提示:查看binlog日志需要使用mysqlbinlog打开
1.开启MySQL的log-bin日志功能
/etc/my.cnf
[mysqld]
log_bin=mysql_bin
server-id=1
2.指定开始位置到结束位置，从pos466开始到531结束
mysqlbinlog --no-defaults mysql_bin.000001 --start-position=466 --stop-position=531 -r pos.sql
3.指定开始位置到文件结束
mysqlbinlog --no-defaults mysql_bin.000001 --start-position=531 -r pos531-end.sql
4.指定时间来恢复
mysqlbinlog --no-defaults mysql-bin.000001 --start-datetime='2020-1-22 17:30:40' --stop-datetime='2020-3-22 17:30:58' -r time.sql

# 导出表到文件
SELECT columnlist FROM table WHERE condition INTO OUTFILE 'filename'
mysqldump -T path dbname tablename -u root -p
mysql -u root -p [--vertical] [-html|-xml] --execute="SELECT * FROM person;" dbname > C:\person.txt

# 导入表
SET @@foreign_key_checks=0;
LOAD DATA INFILE 'filename' INTO TABLE tablename
SET @@foreign_key_checks=1;
--命令行工具
mysqlimport -u root -p dbname filename.txt
user-thread:并发导入不同文件

# xtraBackup备份与还原工具
https://www.cnblogs.com/lijiaman/p/12291509.html

# 导入导出
NOTE:执行SELECT INTO OUTFILE和LOAD DATA INFILE需要开启secure_file_priv,空值代表文件可以在任意处或指定具体路径,NULL表示禁止使用

SELECT...INTO OUTFILE的结果只包含了表数据,默认以Tab分隔也可指定分隔符
NOTE:OUTFILE '/path/file'中的path需要有mysql的权限否则会报错
SELECT * FROM `t_order` INTO OUTFILE 'C:\\Users\\chang\\Desktop\\t_order.sql' FIELDS TERMINATED BY ',';

NOTE:LOAD DATA需要有处理文件的权限:GRANT FILE ON *.* TO user@host;
LOAD DATA INFILE 'C:\\Users\\chang\\Desktop\\t_order.sql' INTO TABLE `t_order_bk` FIELDS TERMINATED BY ',';

# 命令行导入工具mysqlimport
mysqlimport -uroot -pServer2008 --local zsy "C:\\Users\\chang\\Desktop\\t_order_bk.sql" --fields-terminated-by=,
OPTION选项:
--fields-terminated-by=字符串:设置字符串为字段之间的分隔符,可以为单个或多个字符。默认值为制表符“\t”
--fields-enclosed-by=字符:设置字符来括住字段的值,只能为单个字符
--fields-optionally-enclosed-by=字符:设置字符括住CHAR、VARCHAR和TEXT等字符型字段,只能为单个字符
--fields-escaped-by=字符:设置转义字符,默认值为反斜线“\”
--lines-terminated-by=字符串:设置每行数据结尾的字符,可以为单个或多个字符,默认值为“\n”
--ignore-lines=n:表示可以忽略前n行
####################### 备份还原 #######################

####################### 日志 #######################
错误日志:记录MySQL服务启动,运行或停止服务时出现的问题
查询日志:记录建立的客户端连接和执行的语句
二进制日志:记录所有更改数据的语句,可以用于数据复制
慢查询日志:记录所有执行时间超过long_query_time的所有查询或不使用索引的查询

# 查询日志 #
SHOW VARIABLES LIKE 'general_log';              -- 查看日志是否开启
SET GLOBAL general_log=on;                          -- 开启日志功能

SHOW VARIABLES LIKE 'general_log_file';        -- 看看日志文件保存位置
SET GLOBAL general_log_file='/usr/local/mysql/data/general.log'; -- 设置日志文件保存位置

SHOW VARIABLES LIKE 'log_output';               -- 看看日志输出类型table或file
SET GLOBAL log_output='table';                           -- 表示将日志存入数据库,这样日志信息就会被写入到mysql.slow_log表中
SET GLOBAL log_output='file';                              -- 表示将日志存入文件,默认值是FILE

# 开启查询日志(在my.ini|my.cnf文件中添加如下内容)
general_log=1
general_log_file=/usr/local/mysql/data/general.log

# 错误日志 #
SHOW VARIABLES LIKE 'log_error'

# 开启错误日志(在my.ini|my.cnf文件中添加如下内容)
log_error=/usr/local/mysql/mysql-error.log

# 慢查询日志 #
SHOW VARIABLES LIKE '%long_query%'
SHOW VARIABLES LIKE '%slow_query%'
SHOW VARIABLES LIKE '%log_queries_not_using_indexes%'

SET slow_query_log='ON'
SET GLOBAL long_query_time=2;
# 修改慢查询日志输出方式
SHOW VARIABLES LIKE 'log_output';
SET GLOBAL log_output='table';
DESC mysql.slow_log;

# 二进制日志 #
log-bin[=name]
binlog_format:参数决定了二进制日志文件的内容格式,其取值可以是statement,row或者是mixed
max_binlog_size:指定了单个二进制日志文件的最大值,如果超过该值,则产生新的二进制日志文件,后缀名+1,并记录到.index文件中,默认是1G
binlog_cache_size：对InnoDB来说,所有未提交的事务的二进制日志都会先写入到缓存中,只有当事务提交时将缓存中的二进制日志写入到日志文件中。而缓存的大小由binlog_cache_size决定，默认是32K。当一个线程开启一个事务时，会自动分配32K的大小的binlog缓存空间,当事务的记录大于32K大小的时候，则会把缓存中的日志写入到临时文件中，可以通过查询binlog_cache_disk_use参数查看写入到临时文件的次数
binlog_do_db/binlog_ignore_db:表示需要写入和忽略哪些库的二进制日志的写入,默认是空,表示所有数据库的二进制日志都要写入
log_slave_update:参数用来将从master上取得并执行的二进制日志写入到自己的二进制日志文件中去，通常在需要搭建master=>slave=>slave (一主多从，多主多从)架构的复制时，需要设置该参数

备份二进制日志:
FLUSH LOGS; # 生成新的二进制日志文件,备份之前的二进制日志
恢复二进制日志:
mysqlbinlog binlog.[0-10]* | mysql -uroot -p test
先将多个二进制日志文件导出再导入
mysqlbinlog binlog.000001 >> /tmp/statements.sql
mysqlbinlog binlog.000002 >> /tmp/statements.sql
mysql -uroot -pServer2008 -e "source /tmp/statements.sql"

# 刷新日志(生成新的bin log文件)
FLUSH LOGS
mysqladmin -u root -p flush-logs
mysqladmin refresh
SHOW MASTER STATUS;

RESET master; # 重置master删除所有binlog文件
PURGE MASTER LOGS TO 'mysql-bin.010'; # 删除mysql-bin.010之前的所有日志
PURGE MASTER LOGS BEFORE '2020-04-14 22:46:26'; # 删除2020-04-14 22:46:26之前产生的所有日志
PURGE MASTER LOGS BEFORE DATE_SUB(NOW(), INTERVAL 3 DAY); # 清除3天前的 binlog

# 查看是否开启binlog日志
SHOW VARIABLES LIKE 'log_bin%';
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index

# 开启binlog日志(在my.ini|my.cnf文件中添加如下内容)
# 开启binlog日志
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=/usr/local/mysql/mysql-bin.index
# 设置日志格式
binlog-format=mixed

# 临时开启binlog
SET sql_log_bin={0|1}

# 查看所有binlog日志列表
SHOW BINARY LOGS;
SHOW MASTER LOGS;

# 查看master状态即最后(最新)一个binlog日志的编号名称,及其最后一个操作事件pos结束点(Position)值
SHOW MASTER STATUS;

# 刷新log日志,自此刻开始产生一个新编号的binlog日志文件
FLUSH LOGS

# 重置(清空)所有binlog日志
RESET MASTER;

# 查看binlog日志内容(以表格形式)
SHOW BINLOG EVENTS IN 'mysql-bin.000002';

# 删除指定的二进制日志文件
PURGE MASTER|BINARY LOGS TO 'filename' 将删除文件名编号比指定文件名编号小的所有日志文件
PURGE MASTER|BINARY LOGS BEFORE '20130330' 将删除指定日期以前的所有日志文件

# mysqlbinlog命令部分参数
mysqlbinlog filename
-d  //指定库的binlog
-r  //相当于重定向到指定文件
--start-position--stop-position //按照指定位置精确解析binlog日志（精确），如不接--stop-positiion则一直到binlog日志结尾
--start-datetime--stop-datetime //按照指定时间解析binlog日志（模糊，不准确），如不接--stop-datetime则一直到binlog日志结尾

# 使用二进制日志还原数据库
mysqlbinlog --stop-date='2013-03-30' filename|mysql --user --ppass

# 查看二进制日志
mysqlbinlog --no-defaults mysql-bin.000001
mysqlbinlog -vv --no-defaults mysql-bin.000001 # binlog_format=STATEMENT
####################### 日志 #######################

####################### explain语句解释 #######################
select_type: 指定所使用SELECT查询类型;其他可能取值有:PRIMARY,UNION,SUBQUERY等
table:       数据库读取的数据表名字,按读取的先后顺序排列
type:        指定本数据表与其他数据表之间的关联关系,可能取值有:system,const,eq_ref,ref,range,index和all
possible_keys: MySQL在搜索记录时可选用的各个索引
key:         实际选用的索引
key_len:     索引按字节计算的长度,key_len数据越小表示越快
ref:         指出关联关系中另一个数据表里的数据列的名字
rows:        在执行这个查询时预计会从数据表里读出的数据行个数
extra:       与关联操作有关的信息
                索引覆盖: using index
                回表查询: using index condition 或 using index & using where
####################### explain语句解释 #######################

####################### 锁 #######################
# Shared and Exclusive Locks-共享锁和排他锁(行级锁)
当给select语句应用lock in share mode或者for update，或者更新某条记录时，加的都是行级别的锁

# Intention Locks-意向锁(表级锁)
分为intention shared lock(IS)和intention exclusive lock(IX),但IS和IX之间并不互斥,也就是说可以同时给不同的事务加上IS和IX
作用: 和表级别的共享锁和排他锁互斥,和行级别没有关系！

# Record Locks-行锁
单个行记录上的锁
InnoDB中,表都以索引的形式存在,每一个索引对应一颗B+树,这里的行锁锁的就是B+中的索引记录。共享锁和排他锁，就是将锁加在这里

# Gap Locks-间隙锁
锁定一个范围,但不包括记录本身
锁住的是索引记录间的空隙,是为了解决幻读问题被引入的。有一点需要注意，间隙锁和间隙锁本身之间并不冲突，仅仅和插入这个操作发生冲突

# Next-Key lock:Gap Lock+Record Lock
锁定一个范围,并且锁定记录本身
是行锁（Record）和间隙锁的并集.在RR级别下,InnoDB使用next-key锁进行树搜索和索引扫描
NOTE: 加锁的基本单位是next-key lock

# 加锁规则
MySQL 版本：5.x - 5.7.24， 8.0 - 8.0.13. 我是 5.7.27 也未发现问题。
规则包括：两个“原则”、两个“优化”和一个“bug”。
原则1：加锁的基本单位是next-key lock。next-key lock是前开后闭区间
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候,next-key lock退化为间隙锁
一个Bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

# 全局锁(让整个数据库处于只读状态)
FLUSH TABLES WITH READ LOCK;
FLUSH TABLES t WITH READ LOCK;

解锁的方式也是UNLOCK TABLES;

# 导数据之前启动一个事务,来确保拿到一致性快照
设置事务为RR模式,然后利用事务的特性,来获得一致性的数据,但是:在mysqldump运行期间,不能执行alter table,drop table,rename table,truncate table等等的DDL语句,因为一致性读和这些语句时无法隔离的
mysqldump --single-transaction

# 表锁
使用表锁需要注意几点:
1）使用LOCK TABLES虽然可以给InnoDB加表级锁，表级锁不是InnoDB存储引擎层管理的，而是由其上一层MySQL Server负责的
2）在用LOCK TABLES对InnoDB表加锁时需要注意，要将AUTOCOMMIT设置为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK_TABLES隐含提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加表级锁
SET AUTOCOMMIT=0;
LOCK TABLES table1 WRITE, table2 READ,...；
[do something....]
COMMIT;
UNLOCK TABLES;

Lock Tables....READ不会阻塞其他线程对表数据的读取,会阻塞其他线程对数据变更
Lock Tables....WRITE会阻塞其他线程对数据读和写
Lock Tables....READ不允许对表进行更新操作(新增、删除也不行),并且不允许访问未被锁住的表
Lock Tables....WRITE允许对被锁住的表进行增删改查,但不允许对其他表进行访问

# 查询MySQL是否存在lock tables锁状态
SHOW STATUS LIKE "%lock%";
SHOW OPEN TABLES WHERE In_use > 0;

# 排他锁
SELECT col FROM table WHERE ID=1 FOR UPDATE;

# 共享锁
SELECT col FROM table WHERE ID=1 LOCK IN SHARE MODE;

# 打印锁信息到错误日志
mysqladmin debug

# 查询谁阻塞谁等待以及等待多久
SELECT r.trx_id AS waiting_trx_id,r.trx_mysql_thread_id AS waiting_thread,
              TIMESTAMPDIFF(SECOND,r.trx_wait_started,CURRENT_TIMESTAMP) AS wait_time,
               r.trx_query AS waiting_query,
               l.lock_table AS waiting_table_lock,
               b.trx_id AS blocking_trx_id,b.trx_mysql_thread_id AS blocking_thread,
               SUBSTRING(p.host,1,INSTR(p.host,':')-1) AS blocking_host,
               SUBSTRING(p.host,INSTR(p.host,':')+1) AS blocking_port,
               IF(p.command="Sleep",p.time,0) AS idle_in_trx,
               b.trx_query AS blocking_query
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS AS w
INNER JOIN INFORMATION_SCHEMA.INNODB_TRX AS b ON b.trx_id=w.blocking_trx_id
INNER JOIN INFORMATION_SCHEMA.INNODB_TRX AS r ON r.trx_id=w.requesting_trx_id
INNER JOIN INFORMATION_SCHEMA.INNODB_LOCKS AS l ON w.requested_lock_id=l.lock_id
LEFT JOIN INFORMATION_SCHEMA.PROCESSLIST AS p ON p.id=b.trx_mysql_thread_id
ORDER BY wait_time DESC;

# 多少查询被哪些线程阻塞
SELECT CONCAT('thread ',b.trx_mysql_thread_id,' from ',p.host) AS who_blocks,
            IF(p.command='Sleep',p.time,0) AS idle_in_trx,
            MAX(TIMESTAMPDIFF(SECOND,r.trx_wait_started,NOW())) AS max_wait_time,
            COUNT(*) AS num_waiters
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS AS w
INNER JOIN INFORMATION_SCHEMA.INNODB_TRX AS b ON b.trx_id=w.blocking_trx_id
INNER JOIN INFORMATION_SCHEMA.INNODB_TRX AS r ON r.trx_id=w.requesting_trx_id
LEFT JOIN INFORMATION_SCHEMA.PROCESSLIST AS p ON p.id=b.trx_mysql_thread_id
GROUP BY who_blocks ORDER BY num_waiters DESC;
####################### 锁 #######################

####################### 用户权限 #######################
特别需要注意,在MySQL中账号由两部分组成:
1.user
2.host
即使user相同,只要host不同,也会被认为是不同账号
默认情况下,创建的用户host为'%',这是一个匹配符,跟模糊查询里的意思一样,表示匹配所有

# 创建用户
CREATE USER [用户名] IDENTIFIED BY '[密码]';

# 修改密码
SET PASSWORD FROM '用户名' @host=password('新密码');
UPDATE mysql.user SET password=password('新密码') WHERE user='用户名' AND host='%';

# 设置用户权限
将所有数据库上的所有权利都授予通过本机连接的VIP用户
GRANT ALL ON *.* TO vip@'127.0.0.1';
将数据库books上的所有权利都授予所有连接的vip用户
GRANT ALL PRIVILEGES ON books.* TO vip@'%';
将books数据库上的users表的访问权限开发给vip用户;
GRANT select ON books.users TO vip@'%';
WITH GRANT POTIONS的意思是可以给vip给予权限给别的用户
GRANT ALL ON *.* TO vip@'%' WITH GRANT POTIONS;

# 设置权限后要刷新权限
FLUSH PRIVILEGES;
####################### 用户权限 #######################

####################### 恢复数据 #######################
1. 确认数据库是否开启binlog日志
SHOW VARIABLES LIKE 'log_%';
查看以下几行的内容:
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index
2. 开启binlog日志
在my.ini文件中添加如下内容
# Binary Logging
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=D:\program\green\64\mysql-5.7.19-winx64\mysql-bin.log
# 设置日志格式
binlog-format=mixed
3. 查看最新的binlog日志文件
SHOW MASTER STATUS;
4. 查看 binlog 日志文件
SHOW BINLOG EVENTS IN 'mysql-bin.000001';
5. 使用mysqlbinlog恢复二进制日志文件
NOTE:如果是恢复数据库,则不需要带上数据库名称
mysqlbinlog binlog日志文件 --start-position 初始偏移量的位置 --stop-position 结束偏移量的位置 | mysql -u root -p 数据库名称;
例:
mysqlbinlog d:\Mysql-binlog\mysql-bin.000043 --start-position 710 --stop-position 996 | mysql -u root -p pingtouge;
####################### 恢复数据 #######################

####################### MySQL查询缓存 #######################
# 开启缓存
SET GLOBAL query_cache_size=600000; --设置缓存内存大小
SET GLOBAL query_cache_type=ON;       --开启查询缓存

# 关闭缓存
SET GLOBAL query_cache_size=0;           --设置缓存内存大小为0，即初始化是不分配缓存内存
SET GLOBAL query_cache_type=OFF;     --关闭查询缓存

# MySQL查询缓存相关的配置参数
SHOW VARIABLES LIKE '%query_cache%';
+------------------------------+---------+
| Variable_name | Value |
+------------------------------+---------+
| have_query_cache | YES |                          --查询缓存是否可用
| query_cache_limit | 1048576 |                   --可缓存具体查询结果的最大值
| query_cache_min_res_unit | 4096 |           --查询缓存分配的最小块的大小(字节)
| query_cache_size | 599040 |                      --查询缓存的大小
| query_cache_type | ON |                           --是否支持查询缓存
| query_cache_wlock_invalidate | OFF |       --控制当有写锁加在表上的时候，是否先让该表相关的 Query Cache失效
+------------------------------+---------+
have_query_cache
该MySQL Server是否支持Query Cache。
query_cache_limit
MySQL能够缓存的最大查询结果，查询结果大于该值时不会被缓存。默认值是1048576(1MB)如果某个查询的结果超出了这个值，Qcache_not_cached的值会加1，如果某个操作总是超出，可以考虑在SQL中加上SQL_NO_CACHE来避免额外的消耗。
query_cache_min_res_unit
查询缓存分配的最小块的大小(字节)。 默认值是4096(4KB)。当查询进行的时候，MySQL把查询结果保存在qurey cache中，但如果要保存的结果比较大，超过query_cache_min_res_unit的值 ，这时候mysql将一边检索结果，一边进行保存结果，所以，有时候并不是把所有结果全部得到后再进行一次性保存，而是每次分配一块query_cache_min_res_unit大小的内存空间保存结果集，使用完后，接着再分配一个这样的块，如果还不不够，接着再分配一个块，依此类推，也就是说，有可能在一次查询中，mysql要进行多次内存分配的操作。适当的调节query_cache_min_res_unit可以优化内存如果你的查询结果都是一些small result,默认的query_cache_min_res_unit可能会造成大量的内存碎片如果你的查询结果都是一些larger resule，你可以适当的把query_cache_min_res_unit调大
query_cache_size
为缓存查询结果分配的内存的数量，单位是字节，且数值必须是1024的整数倍。默认值是0，即禁用查询缓存。请注意如果设置了该值，即使query_cache_type设置为0也将分配此数量的内存。
query_cache_type
设置查询缓存类型，默认为ON。设置GLOBAL值可以设置后面的所有客户端连接的类型。客户端可以设置SESSION值以影响他们自己对查询缓存的使用。
query_cache_wlock_invalidate
如果某个表被锁住，是否返回缓存中的数据，默认关闭，也是建议的。一般情况，当客户端对MyISAM表进行WRITE锁定时，如果查询结果位于查询缓存中，则其它客户端未被锁定，可以对该表进行查询。将该变量设置为1，则可以对表进行WRITE锁定，使查询缓存内所有对该表进行的查询变得非法。这样当锁定生效时，可以强制其它试图访问表的客户端来等待

# 查看缓存状态
SHOW STATUS LIKE 'Qcache%';
+-------------------------+--------+
| Variable_name | Value |
+-------------------------+--------+
| Qcache_free_blocks | 1 |                          --在查询缓存中的闲置块，如果该值比较大，则说明Query Cache中的内存碎片可能比较多。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个较大的空闲内存块。
| Qcache_free_memory | 382704 |             --剩余缓存的大小
| Qcache_hits | 198 |                                   --缓存命中次数
| Qcache_inserts | 131 |                              --缓存被插入的次数，也就是查询没有命中的次数。
| Qcache_lowmem_prunes | 0 |                  --由于内存低而被删除掉的缓存条数，如果这个数值在不断增长，那么一般是Query Cache的空闲内存不足（通过Qcache_free_memory判断），或者内存碎片较严重（通过Qcache_free_blocks判断）。
| Qcache_not_cached | 169 |                      --没有被缓存的条数，有三种情况会导致查询结果不会被缓存：其一，由于query_cache_type的设置；其二，查询不是SELECT语句；其三，使用了now()之类的函数，导致查询语句一直在变化。
| Qcache_queries_in_cache | 128 |             --缓存中有多少条查询语句
| Qcache_total_blocks | 281 |                     --总块数
+-------------------------+--------+

# 清理查询缓存内存碎片
FLUSH QUERY CACHE;

# 从查询缓存中移除所有查询
RESET QUERY CACHE;

# 关闭所有打开的表，同时该操作会清空查询缓存中的内容
FLUSH TABLES;
####################### MySQL查询缓存 #######################

####################### mysql.ini #######################
# 数据库连接超时问题处理
解决方案：
1. 修改my.ini配置，增加超时时间
2. 连接url中添加“&autoReconnect=true”
在port=3306下面添加如下配置:
wait_timeout=31536000
interactive_timeout=31536000
3. 这种情况也有可能是数据库连接池maxIdleTime配置导致的
<!-- 最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --> 
<property name="maxIdleTime" value="0"></property> 

# sync_binlog
设置为1,表示每次事务的binlog都直接持久化到磁盘(注意是这里指的是binlog日志本身落盘),保证mysql重启后binlog记录是完整的
NOTE:sync_binlog和innodb_flush_log_at_trx_commit这两个参数决定了是否等待直到将redo log和bin log持久化之后再返回
sync_binlog=0,表示每次提交事务都只write,不fsync
sync_binlog=1,表示每次提交事务都会执行fsync
sync_binlog=N(N>1)的时候,表示每次提交事务都write,但累积N个事务后才fsync。但如果宕机了可能会丢失最后的N条语句

# innodb_flush_log_at_trx_commit
设置为1,表示每次事务的redolog都直接持久化到磁盘(注意是这里指的是redolog日志本身落盘),保证mysql重启后数据不丢失
0:log buffer将每秒一次地写入log file中,并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候,不会主动触发写入磁盘的操作
  表示事务提交时不进行写入redo log操作,这个操作仅在master thread中完成,而在master thread中每1秒进行一次重做日志的fsync操作,因此实例crash最多丢失1秒钟内的事务(master thread是负责将缓冲池中的数据异步刷新到磁盘保证数据的一致性)
1:每次事务提交时MySQL都会调用一次fsync操作把log buffer的数据写入log file,并且flush(刷到磁盘)中去,该模式为系统默认
2:每次事务提交时MySQL都会把log buffer的数据写入log file,但是flush(刷到磁盘)操作并不会同时进行。该模式下MySQL会每秒执行一次flush(刷到磁盘)操作
  当设置参数为2时,则在事务提交时只做write操作,只保证将redo log buffer写到系统的页面缓存中,不进行fsync操作,因此如果MySQL数据库宕机时,不会丢失事务,但操作系统宕机则可能丢失事务
NOTE:
当设置为0:该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失
当设置为1:该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务
当设置为2:该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失
查找资料时候看到其他文章说innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数，当两个参数都设置为1的时候写入性能最差，推荐做法是innodb_flush_log_at_trx_commit=2，sync_binlog=500 或1000

# innodb_buffer_pool_size
推荐将数据全然保存在innodb_buffer_pool_size,即按存储量规划innodb_buffer_pool_size的容量。这样你能够全然从内存中读取数据。最大限度降低磁盘操作
SHOW GLOBAL STATUS LIKE 'innodb_buffer_pool_pages_%';
发现Innodb_buffer_pool_pages_free为0则说明buffer pool已经被用光,须要增大innodb_buffer_pool_size

# 慢查询日志
记录全部查询。这在用 ORM 系统或者生成查询语句的系统非常实用。注意不要在生产环境用。否则会占满你的磁盘空间。
log=/var/log/mysql.log

配置示例:
slow_query_log=1 # 表示开启慢查询
slow_query_log_file=/var/lib/mysql/slow-query.log # 表示慢查询日志存放的位置;注意:slow_query_log_file 的路径不能随便写,否则MySQL服务器可能没有权限将日志文件写到指定的目录中
long_query_time=2 # 表示查询>=2秒才记录日志
log_queries_not_using_indexes=1 # 记录没有使用索引的SQL语句

# 分析慢查询日志
获取返回记录集最多的10个sql
mysqldumpslow -s r -t 10 /var/lib/mysql/slow-query.log
获取访问次数最多的10个sql
mysqldumpslow -s c -t 10 /var/lib/mysql/slow-query.log
获取按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/slow-query.log

# 导入导出限制(设置为空字符串为不限制)
secure_file_priv=/home

# 脏页比例
innodb_io_capacity不要让它经常接近75%
脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到的,具体的命令参考下面的代码:
SELECT VARIABLE_VALUE INTO @a FROM performance_schema.global_status WHERE VARIABLE_NAME='Innodb_buffer_pool_pages_dirty';
SELECT VARIABLE_VALUE INTO @b FROM performance_schema.global_status WHERE VARIABLE_NAME='Innodb_buffer_pool_pages_total';
SELECT @a/@b;
####################### mysql.ini #######################

####################### MySQL优化 #######################
# GROUP BY优化
1.如果对GROUP BY语句的结果没有排序要求,要在语句后面加ORDER BY NULL
2.尽量让GROUP BY过程用上表的索引,不但不需要临时表还不需要额外的排序
3.如果GROUP BY需要统计的数据量不大,尽量只使用内存临时表;也可以通过适当调大tmp_table_size参数,来避免用到磁盘临时表
4.如果数据量实在太大,使用SQL_BIG_RESULT这个提示,来告诉优化器直接使用排序算法得到GROUP BY的结果

# IN优化
IN关键字适合主表大子表小
EXIST关键字适合主表小子表大

# 开启profiling
SELECT @@profiling;
SET profiling = 1;

# 查看执行的SQL列表
SHOW PROFILES;

# 查询指定ID的执行详细信息
SHOW PROFILE FOR QUERY Query_ID;

# 获取CPU、Block IO等信息
SHOW PROFILE block io,cpu FOR QUERY Query_ID;
SHOW PROFILE cpu,block io,memory,swaps,context switches,source FOR QUERY Query_ID;
SHOW PROFILE ALL FOR QUERY Query_ID;
####################### MySQL优化 #######################

####################### 分表分区 #######################
NOTE:不论创建何种分区,如果表中存在主键或唯一索引时,分区列必须是唯一索引一个组成部分
# 对于RANGE分区的查询,优化器只能对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行进行优化选择
# 查看表分区
SELECT table_name,partition_name,table_rows FROM information_schema.PARTITIONS WHERE table_name='t' AND table_schema=DATABASE()\G;

1. RANGE分区:按照每年每月分区
CREATE TABLE sales (
money INT UNSIGNED NOT NULL,
date DATETIME
)ENGINE=INNODB
PARTITION BY RANGE(TO_DAYS(date))(
PARTITION p201001 VALUES LESS THAN (TO_DAYS('2010-02-01')),
PARTITION p201002 VALUES LESS THAN (TO_DAYS('2010-03-01')),
PARTITION p201003 VALUES LESS THAN (TO_DAYS('2010-04-01'))
);
2. LIST分区
CREATE TABLE t(
a INT,
b INT
)ENGINE=INNODB
PARTITION BY LIST(b)(
PARTITION p0 VALUES IN (1,3,5,7,9),
PARTITION P1 VALUES IN (0,2,4,6,8)
);

3. HASH分区(PARTITIONS num表示分区数量)
CREATE TABLE t_hash(
a INT,
b DATETIME
)ENGINE=innodb
PARTITION BY HASH(YEAR(b))
PARTITIONS 4;

CREATE TABLE t_linear_hash(
a INT,
b DATETIME
)ENGINE=innodb
PARTITION BY LINEAR HASH(YEAR(b))
PARTITIONS 4;

4. KEY分区
CREATE TABLE t_key(
a INT,
b DATETIME
)ENGINE=innodb
PARTITION BY KEY(b)
PARTITIONS 4;

以上四种分区,分区条件必须是整形,如果不是整形需要通过函数转化为整形
4. RANGE COLUMNS分区
CREATE TABLE t_columns_range(
a INT,
b DATETIME
)ENGINE=INNODB
PARTITION BY RANGE COLUMNS(b)(
PARTITION p0 VALUES LESS THAN ('2009-01-01'),
PARTITION p1 VALUES LESS THAN ('2010-01-01')
);
或者使用字符串分区:
CREATE TABLE customers_1(
first_name VARCHAR(25),
last_name VARCHAR(25),
street_1 VARCHAR(30),
street_2 VARCHAR(30),
city VARCHAR(15),
renewal DATE
)
PARTITION BY LIST COLUMNS(city)(
PARTITION pRegion_1 VALUES IN ('Oskarshamn','Hogsby','Monsteras'),
PARTITION pRegion_2 VALUES IN ('Vimmerby','Hultsfred','Vastervik'),
PARTITION pRegion_3 VALUES IN ('Nossjo','Eksjo','Vetlanda'),
PARTITION pRegion_4 VALUES IN ('Uppvidinge','Alvesta','Vaxjo')
);
多列分区:
CREATE TABLE rcx(
a INT,
b INT,
c CHAR(3),
d INT
)
PARTITION BY RANGE COLUMNS(a,d,c)(
PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
PARTITION p2 VALUES LESS THAN (15,30,'sss'),
PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
####################### 分表分区 #######################

####################### GEO #######################
/* Function structure for function `func_calc_distance` */
DROP FUNCTION IF EXISTS `func_calc_distance`;
DELIMITER $$
CREATE DEFINER=`wxmsg`@`%` FUNCTION `func_calc_distance`(
	targetLongitude DECIMAL(10,6),	-- 目的地经度
	targetLatitude DECIMAL(10,6),	-- 目的地纬度
	currentLongitude DECIMAL(10,6), -- 当前地点经度
	currentLatitude DECIMAL(10,6)) RETURNS DOUBLE -- 单位:米
BEGIN
	DECLARE result DOUBLE DEFAULT 0;
	SET result = ROUND(6378.138*2*ASIN(SQRT(POW(SIN((targetLatitude*PI()/180-currentLatitude*PI()/180)/2),2)+COS(targetLatitude*PI()/180)*COS(currentLatitude*PI()/180)*POW(SIN((targetLongitude*PI()/180-currentLongitude*PI()/180)/2),2)))*1000);
	RETURN result;      
END$$
DELIMITER ;
使用func_calc_distance的查询语句:
SELECT INST,NAME,longitude,latitude,distance FROM (SELECT INST,NAME,longitude,latitude,func_calc_distance(latitude,longitude,%s,%s) AS distance FROM t_jr_inst WHERE LEV='3' AND longitude IS NOT NULL AND latitude IS NOT NULL) AS tmp WHERE tmp.distance<=MAX_DISTANCE ORDER BY IF(ISNULL(distance),0,1),distance LIMIT 0,MAX_COUNT

SELECT * FROM users_location WHERE
    latitude > '.$lat.' - 1 AND latitude < '.$lat.' + 1 AND longitude > '.$lon.' - 1 AND longitude < '.$lon.' + 1 
    ORDER BY
    ACOS(
        SIN( ( '.$lat.' * 3.1415 ) / 180 ) * SIN( ( latitude * 3.1415 ) / 180 ) + COS( ( '.$lat.' * 3.1415 ) / 180 ) * COS( ( latitude * 3.1415 ) / 180 ) * COS( ( '.$lon.' * 3.1415 ) / 180 - ( longitude * 3.1415 ) / 180 ) 
    ) * 6380 ASC 
    LIMIT 10 ';
####################### GEO #######################