####################### CMD命令 #######################
# 启动MySQL服务
net start mysql

ps -ef | grep mysqld
./mysqld_safe &

# 停止MySQL服务
net stop mysql
./mysqladmin -u root -p shutdown

# 命令
mysql -h hostname -u username -p
      -h 主机名
      -u 用户名
      -p 密码(改字段后面的字符串和-p之间不能有空格)
      -P 端口号
      数据库名
      -e 直接在外面交互式查看数据库里面的东西，而不用登录到数据库里面

# 查看配置文件位置
which mysqld
->/usr/local/mysql/bin/mysqld
/usr/local/mysql/bin/mysqld --verbose --help | grep -A 1 'Default options'

# 字符集
SET NAMES 'charset_name'; 不过这里需要大家特别注意,SET names语句并不会改变客户端的默认字符集
该语句和下边三个语句等效：
SET character_set_client = charset_name;
SET character_set_results = charset_name;
SET character_set_connection = charset_name;

通过执行SHOW VARIABLES LIKE 'character%'命令搞清楚：
character_set_client：服务器是怎样认为客户端发送过来的请求是采用何种字符集编码的
character_set_connection：服务器在运行过程中会采用何种字符集编码请求中的字符
character_set_result：服务器会将响应使用何种字符集编码后再发送给客户端的
####################### CMD命令 #######################

####################### 用户管理 #######################
# 创建用户
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 【PASSWORD】 'password'
             jeffrey   用户名
             localhost 主机名(默认为%即对所有的主机开放权限)
             【PASSWORD】使用哈希值设置密码(利用password('password')生成哈希值)
NOTE:在MySQL5.7中user 表的password已换成了authentication_string
NOTE:password()加密函数已经在8.0.11中移除了,可以使用MD5()函数代替

# 创建用户并授予权限
GRANT INSERT,DELETE,UPDATE,SELECT ON *.* TO 'username'@'%' IDENTIFIED BY 'password';

# 删除用户
DROP USER 'username'@'%'

# 修改密码(使用mysqladmin和GRANT命令设置密码均会加密密码不需要使用PASSWORD()函数)
mysqladmin -u username -h host -p password "newpwd";
SET PASSWORD=PASSWORD('newpwd'); 为了使更改生效需要重新启动MySQL或使用FLUSH PRIVILEGES;语句刷新权限,重新加载权限列表
SET PASSWORD FOR 'username'@'host'=PASSWORD('newpwd');  修改其他用户的密码
GRANT USAGE ON *.* TO 'username'@'host' IDENTIFIED BY 'newpwd';

# 重新加载权限
FLUSH PRIVILEGES;

# 忘记root密码
Windows系统下: 在命令行下切换到MySQL的bin目录
mysqld --skip-grant-tables
mysql-nt --skip-grant-tables
Linux系统下:
mysqld_safe --skip-grant-tables user=mysql
/etc/init.d/mysql start-mysqld --skip-grant-tables

# 查看权限
SHOW GRANTS FOR 'username'@'host'
####################### 用户管理 #######################

####################### 基本操作 #######################
# 查看警告信息
SHOW WARNINGS;

# 查看存储过程和函数
SHOW PROCEDURE|FUNCTION STATUS LIKE 'C%';
SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='sp_name';

# 查看存储过程和函数定义
SHOW CREATE PROCEDURE|FUNCTION sp_name;

# 查看视图
DESCRIBE 视图名;
SHOW TABLE STATUS LIKE 'viewname';
SHOW CREATE VIEW 视图名;
SELECT * FROM information_schema.views;

# 查看触发器
SHOW TRIGGERS;
SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME='trig_update';

# 关闭保护模式
SET SQL_SAFE_UPDATES=ON;
如果我们忘记在DELETE或者UPDATE语句中写WHERE条件,或者WHERE条件里面没有包含索引字段的话,这条语句的执行就会报错

# 查看当前MySQL进程状态
SHOW PROCESSLIST;

# 显式开启表锁
LOCK TABLE user READ/WRITE; 

# 关闭表锁
UNLOCK TABLES;

# 开启事务
所以事务开始时间点，分为两种情况：
1）START TRANSACTION时,是第一条语句的执行时间点,就是事务开始的时间点,第一条select语句建立一致性读的snapshot
2）START TRANSACTION WITH CONSISTENT SNAPSHOT时,则是立即建立本事务的一致性读snapshot,当然也开始事务了

# 查看事务
select * from information_schema.INNODB_TRX;

# 查看锁
select * from information_schema.INNODB_LOCKS;

# 查看锁等待
select * from information_schema.INNODB_LOCK_WAITS;

# 查看正在使用中的表
SHOW OPEN TABLES WHERE In_use > 0;

# 查看表锁、行锁
SHOW STATUS LIKE '%lock%'
SHOW GLOBAL STATUS LIKE "table_locks%";
SHOW STATUS LIKE 'innodb_row_lock%';

# 检查InnoDB的状态
show engine innodb status;

# 会在explain的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。
explain extended select * from film where id = 1;
show warnings;

# type列 这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。
依次从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

# 使用show profiles命令查看查询的详细耗时
set profiling=1;
执行SQL语句;
set profiling=0;
show profiles;
show profile cpu, block io for query 1;

# 区分大小写比较
SELECT BINARY 'a'='A';

# 修改MySQL结束符
DELIMITER //

# 连接MySQL服务器的次数
SHOW STATUS LIKE 'Connections';

# MySQL服务器的上线时间
SHOW STATUS LIKE 'Uptime';

# 慢查询次数
SHOW STATUS LIKE 'Slow_queries';

# 查询操作的次数
SHOW STATUS LIKE 'Com_select';

# 插入操作的次数
SHOW STATUS LIKE 'Com_insert';

# 更新操作的次数
SHOW STATUS LIKE 'Com_update';

# 删除操作的次数
SHOW STATUS LIKE 'Com_delete';

# 禁用/启用索引
ALTER TABLE tablename DISABLE KEYS;
ALTER TABLE tablename ENABLE KEYS;

# 禁用/启用唯一性检查
SET UNIQUE_CHECKS=0;
SET UNIQUE_CHECKS=1;

# 禁用/启用外键检查
SET FOREIGN_HKEYCHECKS=0;
SET FOREIGN_KEYCHECKS=1;

# 禁用/启用自动提交
SET AUTOCOMMIT=0;
SET AUTOCOMMIT=1;

# 查看datadir路径
SHOW VARIABLES LIKE '%datadir%';

# 查看二进制日志是否开启
SHOW VARIABLES LIKE '%log_bin%';

# 字符排序规则collation
字符集+语言名称+后缀
_ai   Accent-insensitive 口音不敏感
_as  Accent-sensitive 口音敏感
_ci   Case-insensitive 大小写不敏感
_cs   Case-sensitive 大小写敏感
_bin Binary 二进制排序
对于是ci后缀的collation(大小写不敏感)也意味着Accent-insensitive(口音不敏感)。同理对于是cs后缀的collation(大小写敏感)也意味着Accent-sensitive(口音敏感)
####################### 基本操作 #######################

####################### 数据库基本操作 #######################
# 创建数据库
CREATE DATABASE test_db CHARACTER SET utf8mb4;

# 删除数据库
DROP DATABASE test_db;

# 修改库的默认编码
ALTER DATABASE test CHARACTER SET utf8mb4;

# 查看数据库定义
SHOW CREATE DATABASE test_db;

# 查看系统支持的引擎类型
SHOW ENGINES;

# 查看默认存储引擎
SHOW VARIABLES LIKE 'default_storage_engine';

# 查看当前字符集
SHOW VARIABLES LIKE 'character_set_%';

# 定期优化重建数据库
mysqlcheck -o –all-databases 会让 ibdata1 不断增大。真正的优化仅仅有重建数据表结构：
CREATE TABLE mydb.mytablenew LIKE mydb.mytable;
INSERT INTO mydb.mytablenew SELECT * FROM mydb.mytable;
ALTER TABLE mydb.mytable RENAME mydb.mytablezap;
ALTER TABLE mydb.mytablenew RENAME mydb.mytable;
DROP TABLE mydb.mytablezap;

# 获取插入的自增ID
SELECT LAST_INSERT_ID();
####################### 数据库基本操作 #######################

####################### 数据表基本操作 #######################
# 创建数据表
CREATE TABLE tb_emp2
(
    id INT(11) PRIMARY KEY,
    name VARCHAR(25),
    deptId INT(11),
    salary FLOAT
);

# 查看数据表
SHOW TABLES;

# 查看表的统计信息
SHOW TABLE STATUS FROM mybatis;

# 查看表的字段
SHOW COLUMNS FROM 数据表;

# 查看创建表时的CREATE TABLE语句
SHOW CREATE TABLE 表名;

# 查看表结构
DESCRIBE 表名;

# 修改表名
ALTER TABLE 旧表名 RENAME 新表名;

# 修改字段数据类型
ALTER TABLE 表名 MODIFY 字段名 数据类型;

# 修改字段名(新数据类型不能为空)
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;

# 添加字段
ALTER TABLE 表名 ADD 新字段名 数据类型 约束条件 (FIRST|AFTER 已存在字段名)；
ALTER TABLE USERS ADD ALIAS VARCHAR(20) COMMENT '别名';

# 删除字段
ALTER TABLE 表名 DROP 字段名;
删除多个字段
ALTER TABLE users DROP COLUMN alias,DROP COLUMN age;

不修改名称 使用modify

# 修改字段
1.不修改名称使用modify
ALTER TABLE users MODIFY name VARCHAR(20) NOT NULL COMMENT '用户名';
2.修改名称使用change,格式是change要修改的名称 新名称
ALTER TABLE users CHANGE name username VARCHAR(20) NOT NULL COMMENT '用户名';

# 修改字段排列位置
ALTER TABLE 表名 MODIFY 字段名 数据类型 FIRST|AFTER 字段名;

# 更改表的存储引擎
ALTER TABLE 表名 ENGINE=InnoDB;

# 删除表的外键关系
ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名;

# 删除表
DROP TABLE [IF EXISTS] 表1,表2...;

# 添加索引
1.添加主键
ALTER TABLE users ADD PRIMARY KEY pk_id (`id`);
2.添加唯一索引
ALTER TABLE users ADD UNIQUE idx_name (`name`);
3.添加普通索引
ALTER TABLE users ADD INDEX idx_name (`age`);
4.添加全文索引
ALTER TABLE users ADD FULLTEXT (`列名`);
5.添加多列索引
ALTER TABLE users ADD INDEX idx_列名1_列名2_列名3 (`列名1`,`列名2`,`列名3`);
6.添加外键
ALTER TABLE 表名 ADD CONSTRAINT fk_引用id FOREIGN KEY(引用id) REFERENCES 被引用表名 (被引用id);
ALTER TABLE 表名 DROP FOREIGN KEY fk_引用id;

# 查看指定表中的创建的索引
SHOW INDEX FROM book;

# 查看索引使用情况
1. SHOW STATUS LIKE 'Handler_read%';
handler_read_key:这个值越高越好，越高表示使用索引查询到的次数
handler_read_rnd_next:这个值越高，说明查询低效

Handler_read_first：索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）
Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）
Handler_read_next：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加
Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC
Handler_read_rnd：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救
Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引
2. SELECT * FROM sys.schema_unused_indexes;

# 开启优化器跟踪
SET SESSION optimizer_trace='enabled=on';
SELECT * FROM user WHERE phone = '15627231000' ORDER BY id LIMIT 1;
-- 查看优化器追踪
SELECT * FROM information_schema.optimizer_trace;
####################### 数据表基本操作 #######################

####################### 函数 #######################
# 返回当前系统的日期和时间
NOW()
SYSDATE()

# 字符串与日期转换
SELECT STR_TO_DATE('2018-9-1 14:25:12','%Y-%m-%d %H:%i:%s');
SELECT DATE_FORMAT(NOW(),'%Y-%m-%d %H:%i:%s');

# UTC时间
UTC_DATE()
UTC_TIME()
UTC_TIMESTAMP()

# UNIX时间戳
UNIX_TIMESTAMP()
UNIX_TIMESTAMP(date)

# 将UNIX时间戳转换为普通格式时间
FROM_UNIXTIME(date)

# 获取星期
DAYOFWEEK(date)  1:周日;2:周一...7:周六;
WEEKDAY(date)    0:周一;1:周二...6:周日;

# 获取一年中的第几天
DAYOFYEAR(date)

# 获取一个月中的第几天
DAYOFMONTH(d)

# 获取年份
YEAR(date)

# 获取季度
QUARTER(date)

# 获取月份(范围值1~12)
MONTH(date)

# 获取小时
HOUR(date)

# 获取分钟
MINUTE(date)

# 获取秒数
SECOND(date)

# 将时间转化为秒
TIME_TO_SEC(time)

# 将秒数转化为小时:分钟:秒
SEC_TO_TIME(seconds)

# 返回字符个数
CHAR_LENGTH(str)

# 返回字节长度(一个汉字3个字节,一个数字或字母一个字节)
LENGTH(str)

# 连接字符串
CONCAT(s1,s2...)

# 连接带分隔符的字符串
CONCAT_WS(x,s1,s2...)

# 获取指定长度的字符串
LEFT(s, length)
RIGHT(s,length)

# 填充字符串
LPAD(s1,length,s2)
RPAD(s1,length,s2)

# 删除空格
LTRIM(s)
RTRIM(s)
TRIM(s)

# 删除两端指定的字符串
TRIM(ss FROM s)

# 重复生成字符串
REPEAT(s,n)

# 替换字符串(使用字符串s2替换字符串s中所有的s1字符串)
REPLACE(s,s1,s2)

# 比较字符串大小
STRCMP(s1,s2)

# 获取子字符串
SUBSTRING(s,index,length)

# 获取子串的位置
LOCATE(ss,s)
POSITION(ss IN s)
INSTR(s,ss)

# IF函数
IF(expr,v1,v2)  (expr<>0 and expr<>NULL 返回v1否则返回v2)

# IFNULL函数(如果v1不为NULL返回v1,否则返回v2)
IFNULL(v1,v2)

# 获取MySQL版本号
VERSION()

# 查看当前用户连接次数
CONNECTION_ID()

# 显示当前所有的连接数和状态
SHOW PROCESSLIST (显示100条)
SHOW FULL PROCESSLIST

# 获取数据库名
DATABASE()
SCHEMA()

# 获取当前登录用户名称
USER()
CURRENT_USER()
SYSTEM_USER()

# 获取字符串的字符集
CHARSET(s)

# 获取字符串的排序方式
COLLATION(s)

# 获取最后一个自动生成的ID
LAST_INSERT_ID()

# 数字格式化(四舍五入方式保留小数点后n位,结果以字符串的形式返回;若n为0,返回结果不包含小数部分)
FORMAT(x,n)

# 重复执行指定的操作
BENCHMARK(count,expr)

# 改变字符集
CONVERT('string' USING latin1)

# 改变数据类型
CAST(x AS type)
CONVERT(x, type)

# 在分组查询中将分组中各个字段的值显示出来
GROUP_CONCAT(name)

# 分组查询后显示所有记录的总和
WITH ROLLUP

# 时间戳与时间相互转换
SELECT UNIX_TIMESTAMP('2020-01-11 09:53:32');
SELECT FROM_UNIXTIME(1578707612);
####################### 函数 #######################

####################### 备份还原 #######################
# 使用mysqldump命令备份
1.-B --databases            指定多个库。增加建库语句和use语句(提示:备份一个表的时候不要加-B,要不然所有表都会出来，就会报错)
2.--compact                  去掉注释，适合调试输出
3.-A --all-databases      备份所有库
4.-F                                刷新binlog日志
5.--master-data             增加binlog日志文件名及对应的位置点
6.-x --lock-all-tables     全局的读锁,会阻止对所有表的写入操作
7.-l                                 该锁不会阻止读,也不会阻止新的数据插入
8.-d                               只备份表结构
9.-t                                只备份数据
10.--signle-transaction 适合innodb事务数据库备份
mysqldump -h host -uroot -ppassword --master-data=2 --default-character-set=utf8 --single-transaction -B dbname | gzip > /opt/back/mysqlbak_$(date +%F).sql.gz
mysqldump -h host -uroot -ppassword --master-data=2 --default-character-set=utf8 --single-transaction -B dbname test_db | gzip > /opt/mysql.bak.sql.gz 备份多个库
官方自带的逻辑备份工具是mysqldump。当mysqldump使用参--single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
前提就是引擎要支持这个隔离级别。比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时候FTWRL命令了就派上用场了。
为什么我们不用set global readonly=true 的命令让全库处于只读的状态呢？
注意，这是生产上严厉禁止的，主要有如下两个原因：
1.在某些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。毫无疑问修改global变量的方式影响面更大。
2.在异常处理机制上存在差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，很容易造成生产事故。

# 分库备份sh脚本
#!/bin/bash

MYUSER="root"
MYPASS="guoke123"
MYLOG="mysql -u$MYUSER -p$MYPASS -e"
MYDUMP="mysqldump -u$MYUSER -p$MYPASS -x -F"
DBLIST=$($MYLOG  "show databases;" | sed 1d | grep -Ev 'info|mysq|per|sys')
DIR=/backup
[ ! -d $DIR ] && mkdir $DIR
cd $DIR

for dbname in $DBLIST
do
    TABLIST=$($MYLOG "show tables from $dbname;" | sed 1d)
    for tabname in $TABLIST
    do
        mkdir -p $DIR/$dbname
        $MYDUMP $dbname $tabname  --events |gzip > $DIR/${dbname}/${tabname}_$(date +%F_%T).sql.gz
    done
done

# 还原数据库
1. mysql> source test1.sql; 恢复test1表
2. /usr/local/mysql5.7/bin/mysql --socket=/tmp/mysql.sock --port=3306 -uroot -p -e "use rec ; source  test1.sql;"
3. mysql -uroot -p < /opt/mysql_test1.sql         #备份时加-B参数恢复方法
    mysql -uroot -p test < /opt/mysql_test1.sql  #备份时没加-B参数恢复方法

# 使用MySQL的binlog增量恢复
提示:查看binlog日志需要使用mysqlbinlog打开
1.开启MySQL的log-bin日志功能
/etc/my.cnf
[mysqld]
log_bin=mysql_bin
server-id=1
2.指定开始位置到结束位置，从pos466开始到531结束
mysqlbinlog --no-defaults mysql_bin.000001 --start-position=466 --stop-position=531 -r pos.sql
3.指定开始位置到文件结束
mysqlbinlog --no-defaults mysql_bin.000001 --start-position=531 -r pos531-end.sql
4.指定时间来恢复
mysqlbinlog --no-defaults mysql-bin.000001 --start-datetime='2020-1-22 17:30:40' --stop-datetime='2020-3-22 17:30:58' -r time.sql

# 导出表到文件
SELECT columnlist FROM table WHERE condition INTO OUTFILE 'filename'
mysqldump -T path dbname tablename -u root -p
mysql -u root -p [--vertical] [-html|-xml] --execute="SELECT * FROM person;" dbname > C:\person.txt

# 导入表
LOAD DATA INFILE 'filename' INTO TABLE tablename
mysqlimport -u root -p dbname filename.txt

# xtraBackup备份与还原工具
https://www.cnblogs.com/lijiaman/p/12291509.html
####################### 备份还原 #######################

####################### 日志 #######################
错误日志: 记录MySQL服务启动,运行或停止服务时出现的问题
查询日志: 记录建立的客户端连接和执行的预计
二进制日志: 记录所有更改数据的语句,可以用于数据复制
慢查询日志: 记录所有执行时间超过long_query_time的所有查询或不使用索引的查询

# 错误日志
SHOW VARIABLES LIKE 'log_error' 定位文件

# 慢查询日志
SHOW VARIABLES LIKE '%long_query%'
SHOW VARIABLES LIKE '%slow_query%'
SHOW VARIABLES LIKE '%log_queries_not_using_indexes%'
  修改慢查询日志输出方式
SHOW VARIABLES LIKE 'log_output';
SET  global log_output='table';
DESC mysql.slow_log;

# 查询日志
general_log=on
general_log_file=/usr/local/mysql/data/general_log

# 二进制日志
log-bin[=name]
binlog_format:参数决定了二进制日志文件的内容格式,其取值可以是statement,row或者是mixed
max_binlog_size:指定了单个二进制日志文件的最大值,如果超过该值,则产生新的二进制日志文件,后缀名+1,并记录到.index文件中,默认是1G
binlog_cache_size：对InnoDB来说,所有未提交的事务的二进制日志都会先写入到缓存中,只有当事务提交时将缓存中的二进制日志写入到日志文件中。而缓存的大小由binlog_cache_size决定，默认是32K。当一个线程开启一个事务时，会自动分配32K的大小的binlog缓存空间,当事务的记录大于32K大小的时候，则会把缓存中的日志写入到临时文件中，可以通过查询binlog_cache_disk_use参数查看写入到临时文件的次数
binlog_do_db/binlog_ignore_db:表示需要写入和忽略哪些库的二进制日志的写入,默认是空,表示所有数据库的二进制日志都要写入
log_slave_update:参数用来将从master上取得并执行的二进制日志写入到自己的二进制日志文件中去，通常在需要搭建master=>slave=>slave (一主多从，多主多从)架构的复制时，需要设置该参数

# 刷新日志
FLUSH LOGS
mysqladmin -u root -p flush-logs
mysqladmin refresh

# 查看是否开启binlog日志
SHOW VARIABLES LIKE 'log_%';
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index

开启binlog日志(在my.ini|my.cnf文件中添加如下内容):
# Binary Logging
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=D:\program\green\64\mysql-5.7.19-winx64\mysql-bin.log
# 设置日志格式
binlog-format=mixed

SHOW BINARY LOGS;
mysqlbinlog filename

# 删除所有二进制日志文件
RESET MASTER;

# 删除指定的二进制日志文件
PURGE MASTER|BINARY LOGS TO 'filename' 将删除文件名编号比指定文件名编号小的所有日志文件
PURGE MASTER|BINARY LOGS BEFORE '20130330' 将删除指定日期以前的所有日志文件

# 使用二进制日志还原数据库
mysqlbinlog --stop-date='2013-03-30' filename|mysql --user --ppass

# 开启/停止二进制日志功能
SET sql_log_bin={0|1}
####################### 日志 #######################

####################### explain语句解释 #######################
select_type: 指定所使用SELECT查询类型;其他可能取值有:PRIMARY,UNION,SUBQUERY等
table:       数据库读取的数据表名字,按读取的先后顺序排列
type:        指定本数据表与其他数据表之间的关联关系,可能取值有:system,const,eq_ref,ref,range,index和all
possible_keys: MySQL在搜索记录时可选用的各个索引
key:         实际选用的索引
key_len:     索引按字节计算的长度,key_len数据越小表示越快
ref:         指出关联关系中另一个数据表里的数据列的名字
rows:        在执行这个查询时预计会从数据表里读出的数据行个数
extra:       与关联操作有关的信息
                索引覆盖: using index
                回表查询: using index condition 或 using index & using where
####################### explain语句解释 #######################

####################### 锁 #######################
# Shared and Exclusive Locks-共享锁和排他锁(行级锁)
当给select语句应用lock in share mode或者for update，或者更新某条记录时，加的都是行级别的锁

# Intention Locks-意向锁(表级锁)
分为intention shared lock(IS)和intention exclusive lock(IX),但IS和IX之间并不互斥,也就是说可以同时给不同的事务加上IS和IX
作用: 和表级别的共享锁和排他锁互斥,和行级别没有关系！

# Record Locks-行锁
InnoDB 中,表都以索引的形式存在,每一个索引对应一颗B+树,这里的行锁锁的就是B+中的索引记录。共享锁和排他锁，就是将锁加在这里

# Gap Locks-间隙锁
锁住的是索引记录间的空隙,是为了解决幻读问题被引入的。有一点需要注意，间隙锁和间隙锁本身之间并不冲突，仅仅和插入这个操作发生冲突

# Next-Key lock
是行锁（Record）和间隙锁的并集.在RR级别下,InnoDB使用next-key锁进行树搜索和索引扫描
NOTE: 加锁的基本单位是next-key lock

# 加锁规则
MySQL 版本：5.x - 5.7.24， 8.0 - 8.0.13. 我是 5.7.27 也未发现问题。
规则包括：两个“原则”、两个“优化”和一个“bug”。
原则1：加锁的基本单位是next-key lock。next-key lock是前开后闭区间
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候,next-key lock退化为间隙锁
一个Bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

# 全局锁(让整个数据库处于只读状态)
FLUSH TABLES WITH READ LOCK;
FLUSH TABLES t WITH READ LOCK;

# 导数据之前启动一个事务,来确保拿到一致性快照
设置事务为RR模式,然后利用事务的特性,来获得一致性的数据,但是:在mysqldump运行期间,不能执行alter table,drop table,rename table,truncate table等等的DDL语句,因为一致性读和这些语句时无法隔离的
mysqldump --single-transaction

# 表锁
LOCK TABLES 表名 READ/WRITE;
UNLOCK TABLES

# 排他锁
SELECT col FROM table WHERE ID=1 FOR UPDATE;

# 共享锁
SELECT col FROM table WHERE ID=1 LOCK IN SHARE MODE;
####################### 锁 #######################

####################### 配置文件 #######################
[mysqld]
# GENERAL
datadir=/usr/local/mysql/data
socket=/usr/local/mysql/mysql.sock
pid_file=/usr/local/mysql/mysql.pid
user=mysql
port=3306
default_storage_engine=InnoDB
# INNODB
innodb_buffer_pool_size=
innodb_log_file_size=
innodb_file_per_table=1
inno_flush_method=0_DIRECT
# MYISAM
key_buffer_size=
# LOGGING
log_error=/usr/local/mysql/mysql-error.log
slow_query_log=/usr/local/mysql/mysql-slow.log
# OTHER
tmp_table_size=32M
max_heap_table_size=32M
query_cache_type=0
query_cache_size=0
max_connections=
thread_cache=
table_cache=
open_files_limit=65535
[client]
socket=/usr/local/mysql/mysql.sock
port=3306
####################### 配置文件 #######################

####################### 用户权限 #######################
特别需要注意,在MySQL中账号由两部分组成:
1.user
2.host
即使user相同,只要host不同,也会被认为是不同账号
默认情况下,创建的用户host为'%',这是一个匹配符,跟模糊查询里的意思一样,表示匹配所有

# 创建用户
CREATE USER [用户名] IDENTIFIED BY '[密码]';

# 删除用户
DROP USER 用户名;
DELETE FROM mysql.user WHERE user='用户名' AND host='%';

# 修改密码
SET PASSWORD FROM '用户名' @host=password('新密码');
UPDATE mysql.user SET password=password('新密码') WHERE user='用户名' AND host='%';

# 设置用户权限
将所有数据库上的所有权利都授予通过本机连接的VIP用户
GRANT ALL ON *.* TO vip@'127.0.0.1';
将数据库books上的所有权利都授予所有连接的vip用户
GRANT ALL PRIVILEGES ON books.* TO vip@'%';
将books数据库上的users表的访问权限开发给vip用户;
GRANT select ON books.users TO vip@'%';
WITH GRANT POTIONS的意思是可以给vip给予权限给别的用户
GRANT ALL ON *.* TO vip@'%' WITH GRANT POTIONS;

# 设置权限后要刷新权限
FLUSH PRIVILEGES;
####################### 用户权限 #######################

####################### 恢复数据 #######################
1. 确认数据库是否开启binlog日志
SHOW VARIABLES LIKE 'log_%';
查看以下几行的内容:
log_bin                         ON
log_bin_basename      /data/mysql/mysql-bin
log_bin_index              /data/mysql/mysql-bin.index
2. 开启binlog日志
在my.ini文件中添加如下内容
# Binary Logging
server-id=1
# 日志文件的名字以及存储路径(NOTE:日志路径在根目录否则服务启动失败)
log-bin=D:\program\green\64\mysql-5.7.19-winx64\mysql-bin.log
# 设置日志格式
binlog-format=mixed
3. 查看最新的binlog日志文件
SHOW MASTER STATUS;
4. 查看 binlog 日志文件
SHOW BINLOG EVENTS IN 'mysql-bin.000001';
5. 使用mysqlbinlog恢复二进制日志文件
NOTE:如果是恢复数据库,则不需要带上数据库名称
mysqlbinlog binlog日志文件 --start-position 初始偏移量的位置 --stop-position 结束偏移量的位置 | mysql -u root -p 数据库名称;
例:
mysqlbinlog d:\Mysql-binlog\mysql-bin.000043 --start-position 710 --stop-position 996 | mysql -u root -p pingtouge;
####################### 恢复数据 #######################

####################### MySQL查询缓存 #######################
# 开启缓存
SET GLOBAL query_cache_size=600000;  --设置缓存内存大小
SET GLOBAL query_cache_type=ON;       --开启查询缓存

# 关闭缓存
SET GLOBAL query_cache_size=0;           --设置缓存内存大小为0，即初始化是不分配缓存内存
SET GLOBAL query_cache_type=OFF;     --关闭查询缓存

# MySQL查询缓存相关的配置参数
SHOW VARIABLES LIKE '%query_cache%';
+------------------------------+---------+
| Variable_name | Value |
+------------------------------+---------+
| have_query_cache | YES |                          --查询缓存是否可用
| query_cache_limit | 1048576 |                   --可缓存具体查询结果的最大值
| query_cache_min_res_unit | 4096 |           --查询缓存分配的最小块的大小(字节)
| query_cache_size | 599040 |                      --查询缓存的大小
| query_cache_type | ON |                           --是否支持查询缓存
| query_cache_wlock_invalidate | OFF |       --控制当有写锁加在表上的时候，是否先让该表相关的 Query Cache失效
+------------------------------+---------+
have_query_cache
该MySQL Server是否支持Query Cache。
query_cache_limit
MySQL能够缓存的最大查询结果，查询结果大于该值时不会被缓存。默认值是1048576(1MB)如果某个查询的结果超出了这个值，Qcache_not_cached的值会加1，如果某个操作总是超出，可以考虑在SQL中加上SQL_NO_CACHE来避免额外的消耗。
query_cache_min_res_unit
查询缓存分配的最小块的大小(字节)。 默认值是4096(4KB)。当查询进行的时候，MySQL把查询结果保存在qurey cache中，但如果要保存的结果比较大，超过query_cache_min_res_unit的值 ，这时候mysql将一边检索结果，一边进行保存结果，所以，有时候并不是把所有结果全部得到后再进行一次性保存，而是每次分配一块query_cache_min_res_unit大小的内存空间保存结果集，使用完后，接着再分配一个这样的块，如果还不不够，接着再分配一个块，依此类推，也就是说，有可能在一次查询中，mysql要进行多次内存分配的操作。适当的调节query_cache_min_res_unit可以优化内存如果你的查询结果都是一些small result,默认的query_cache_min_res_unit可能会造成大量的内存碎片如果你的查询结果都是一些larger resule，你可以适当的把query_cache_min_res_unit调大
query_cache_size
为缓存查询结果分配的内存的数量，单位是字节，且数值必须是1024的整数倍。默认值是0，即禁用查询缓存。请注意如果设置了该值，即使query_cache_type设置为0也将分配此数量的内存。
query_cache_type
设置查询缓存类型，默认为ON。设置GLOBAL值可以设置后面的所有客户端连接的类型。客户端可以设置SESSION值以影响他们自己对查询缓存的使用。
query_cache_wlock_invalidate
如果某个表被锁住，是否返回缓存中的数据，默认关闭，也是建议的。一般情况，当客户端对MyISAM表进行WRITE锁定时，如果查询结果位于查询缓存中，则其它客户端未被锁定，可以对该表进行查询。将该变量设置为1，则可以对表进行WRITE锁定，使查询缓存内所有对该表进行的查询变得非法。这样当锁定生效时，可以强制其它试图访问表的客户端来等待

# 查看缓存状态
SHOW STATUS LIKE 'Qcache%';
+-------------------------+--------+
| Variable_name | Value |
+-------------------------+--------+
| Qcache_free_blocks | 1 |                          --在查询缓存中的闲置块，如果该值比较大，则说明Query Cache中的内存碎片可能比较多。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个较大的空闲内存块。
| Qcache_free_memory | 382704 |             --剩余缓存的大小
| Qcache_hits | 198 |                                   --缓存命中次数
| Qcache_inserts | 131 |                              --缓存被插入的次数，也就是查询没有命中的次数。
| Qcache_lowmem_prunes | 0 |                  --由于内存低而被删除掉的缓存条数，如果这个数值在不断增长，那么一般是Query Cache的空闲内存不足（通过Qcache_free_memory判断），或者内存碎片较严重（通过Qcache_free_blocks判断）。
| Qcache_not_cached | 169 |                      --没有被缓存的条数，有三种情况会导致查询结果不会被缓存：其一，由于query_cache_type的设置；其二，查询不是SELECT语句；其三，使用了now()之类的函数，导致查询语句一直在变化。
| Qcache_queries_in_cache | 128 |             --缓存中有多少条查询语句
| Qcache_total_blocks | 281 |                     --总块数
+-------------------------+--------+

# 清理查询缓存内存碎片
FLUSH QUERY CACHE;

# 从查询缓存中移除所有查询
RESET QUERY CACHE;

# 关闭所有打开的表，同时该操作会清空查询缓存中的内容
FLUSH TABLES;
####################### MySQL查询缓存 #######################

####################### mysql.ini #######################
# 数据库连接超时问题处理
解决方案：
1. 修改my.ini配置，增加超时时间
2. 连接url中添加“&autoReconnect=true”
在port=3306下面添加如下配置:
wait_timeout=31536000
interactive_timeout=31536000
3. 这种情况也有可能是数据库连接池maxIdleTime配置导致的
<!-- 最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --> 
<property name="maxIdleTime" value="0"></property> 

# innodb_flush_log_at_trx_commit
0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作
1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去，该模式为系统默认
2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作
NOTE:
当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失
当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务
当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失
查找资料时候看到其他文章说innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略以及数据安全性的关键参数，当两个参数都设置为1的时候写入性能最差，推荐做法是innodb_flush_log_at_trx_commit=2，sync_binlog=500 或1000

# innodb_buffer_pool_size
推荐将数据全然保存在 innodb_buffer_pool_size ，即按存储量规划 innodb_buffer_pool_size 的容量。这样你能够全然从内存中读取数据。最大限度降低磁盘操作
SHOW GLOBAL STATUS LIKE 'innodb_buffer_pool_pages_%';
发现 Innodb_buffer_pool_pages_free 为 0，则说明 buffer pool 已经被用光，须要增大 innodb_buffer_pool_size

# 慢查询日志
记录全部查询。这在用 ORM 系统或者生成查询语句的系统非常实用。注意不要在生产环境用。否则会占满你的磁盘空间。
log=/var/log/mysql.log

记录运行时间超过 1 秒的查询：
long_query_time=1
log-slow-queries=/var/log/mysql/log-slow-queries.log
####################### mysql.ini #######################

####################### GEO #######################
SELECT * FROM users_location WHERE
    latitude > '.$lat.' - 1 AND latitude < '.$lat.' + 1 AND longitude > '.$lon.' - 1 AND longitude < '.$lon.' + 1 
    ORDER BY
    ACOS(
        SIN( ( '.$lat.' * 3.1415 ) / 180 ) * SIN( ( latitude * 3.1415 ) / 180 ) + COS( ( '.$lat.' * 3.1415 ) / 180 ) * COS( ( latitude * 3.1415 ) / 180 ) * COS( ( '.$lon.' * 3.1415 ) / 180 - ( longitude * 3.1415 ) / 180 ) 
    ) * 6380 ASC 
    LIMIT 10 ';
####################### GEO #######################